/**
 * @fileoverview Client Document Management Service
 * @module servers/customer-services/modules/core-business/client-management/services/client-document-service
 * @description Comprehensive service for managing client documents with enterprise-grade access control and lifecycle management
 */

const { AppError } = require('../../../../../../shared/lib/utils/app-error');
const logger = require('../../../../../../shared/lib/utils/logger').createLogger({
    serviceName: 'client-document-service'
});
const validator = require('validator');
const crypto = require('crypto');
const path = require('path');
const mongoose = require('mongoose');

// Import secure database service
const database = require('../../../../../../shared/lib/database');

// Import business services
const NotificationService = require('../../notifications/services/notification-service');
const AnalyticsService = require('../../analytics/services/analytics-service');

/**
 * Document Type Constants
 */
const DOCUMENT_TYPES = {
    CONTRACT: 'contract',
    PROPOSAL: 'proposal',
    INVOICE: 'invoice',
    REPORT: 'report',
    PRESENTATION: 'presentation',
    SPECIFICATION: 'specification',
    REQUIREMENT: 'requirement',
    LEGAL: 'legal',
    FINANCIAL: 'financial',
    TECHNICAL: 'technical',
    OTHER: 'other'
};

/**
 * Document Status Constants
 */
const DOCUMENT_STATUS = {
    DRAFT: 'draft',
    REVIEW: 'review',
    APPROVED: 'approved',
    PUBLISHED: 'published',
    ARCHIVED: 'archived',
    OBSOLETE: 'obsolete'
};

/**
 * Classification Level Constants
 */
const CLASSIFICATION_LEVELS = {
    PUBLIC: 'public',
    INTERNAL: 'internal',
    CONFIDENTIAL: 'confidential',
    RESTRICTED: 'restricted',
    TOP_SECRET: 'top_secret'
};

/**
 * Client Document Management Service
 * @class ClientDocumentService
 */
class ClientDocumentService {
    constructor() {
        this._dbService = null;
        this.notificationService = NotificationService;
        this.analyticsService = AnalyticsService;

        // Configuration
        this.config = {
            companyTenantId: process.env.COMPANY_TENANT_ID || 'default',
            platformUrl: process.env.PLATFORM_URL || 'https://yourplatform.com',
            storageBasePath: process.env.DOCUMENT_STORAGE_PATH || '/storage/documents',
            autoGenerateDocumentId: process.env.AUTO_GENERATE_DOCUMENT_ID !== 'false',
            maxDocumentSize: parseInt(process.env.MAX_DOCUMENT_SIZE, 10) || 104857600, // 100MB
            enableVersionControl: process.env.ENABLE_VERSION_CONTROL !== 'false',
            maxVersionsToKeep: parseInt(process.env.MAX_VERSIONS_TO_KEEP, 10) || 10,
            allowedFileTypes: (process.env.ALLOWED_DOCUMENT_TYPES || 'pdf,doc,docx,xls,xlsx,ppt,pptx,txt,csv,jpg,jpeg,png').split(','),
            maxDocumentsPerClient: parseInt(process.env.MAX_DOCUMENTS_PER_CLIENT, 10) || 1000
        };
    }

    /**
     * Get database service instance
     * @private
     * @returns {Object} Database service
     */
    _getDatabaseService() {
        if (!this._dbService) {
            this._dbService = database.getDatabaseService();
        }
        return this._dbService;
    }

    // ============= DOCUMENT CREATION & MANAGEMENT =============

    /**
     * Create a new document with enterprise-grade validation and context inheritance
     */
    async createDocument(documentData, options = {}) {
        const operationId = crypto.randomBytes(8).toString('hex');
        const startTime = Date.now();

        try {
            logger.info('Starting document creation', {
                operationId,
                clientId: documentData.clientId,
                documentName: documentData.documentInfo?.name,
                documentType: documentData.documentInfo?.type,
                userId: options.userId,
                source: options.source || 'manual'
            });

            // PHASE 1: INPUT VALIDATION
            await this._validateDocumentData(documentData);

            if (!documentData.clientId || !mongoose.Types.ObjectId.isValid(documentData.clientId)) {
                throw AppError.validation('Valid client ID is required', {
                    context: {
                        providedClientId: documentData.clientId,
                        field: 'clientId'
                    }
                });
            }

            // PHASE 2: CLIENT VERIFICATION AND CONTEXT INHERITANCE
            const dbService = this._getDatabaseService();
            const Client = dbService.getModel('Client', 'customer');

            const parentClient = await Client.findById(documentData.clientId)
                .select('tenantId organizationId companyName relationship.status')
                .lean();

            if (!parentClient) {
                throw AppError.notFound('Parent client not found', {
                    context: { clientId: documentData.clientId }
                });
            }

            if (parentClient.relationship?.status === 'inactive' ||
                parentClient.relationship?.status === 'churned') {
                throw AppError.validation(
                    'Cannot create documents for inactive or churned clients',
                    {
                        context: {
                            clientId: documentData.clientId,
                            clientStatus: parentClient.relationship.status
                        }
                    }
                );
            }

            // PHASE 3: ACCESS CONTROL VERIFICATION
            if (options.userClientId) {
                if (parentClient._id.toString() !== options.userClientId.toString()) {
                    throw AppError.forbidden(
                        'You can only create documents for your own account',
                        {
                            context: {
                                requestedClientId: documentData.clientId,
                                userClientId: options.userClientId
                            }
                        }
                    );
                }
                logger.debug('Self-service access validated', {
                    operationId,
                    userId: options.userId,
                    clientId: options.userClientId
                });
            } else if (options.tenantId && !options.skipTenantCheck) {
                if (!mongoose.Types.ObjectId.isValid(options.tenantId)) {
                    throw AppError.validation('Valid tenant ID required in authentication context', {
                        context: {
                            providedTenantId: options.tenantId,
                            clientTenantId: parentClient.tenantId
                        }
                    });
                }

                if (parentClient.tenantId.toString() !== options.tenantId.toString()) {
                    throw AppError.forbidden('Access denied to this client', {
                        context: {
                            clientTenantId: parentClient.tenantId.toString(),
                            userTenantId: options.tenantId.toString()
                        }
                    });
                }

                logger.debug('Administrative access validated', {
                    operationId,
                    userId: options.userId,
                    tenantId: options.tenantId
                });
            }

            // PHASE 4: BUSINESS RULE VALIDATION
            await this._checkDocumentLimit(documentData.clientId);

            // Validate file type if provided
            if (documentData.fileDetails?.fileExtension) {
                await this._validateFileType(documentData.fileDetails.fileExtension);
            }

            // Validate file size if provided
            if (documentData.fileDetails?.size) {
                await this._validateFileSize(documentData.fileDetails.size);
            }

            // PHASE 5: DATA ENRICHMENT AND PREPARATION
            if (!documentData.documentId && this.config.autoGenerateDocumentId) {
                documentData.documentId = await this._generateDocumentId();
            }

            documentData.tenantId = parentClient.tenantId;
            documentData.organizationId = parentClient.organizationId;

            // Initialize lifecycle
            if (!documentData.lifecycle) {
                documentData.lifecycle = {};
            }
            documentData.lifecycle.status = documentData.lifecycle.status || DOCUMENT_STATUS.DRAFT;

            // Initialize versioning if enabled
            if (this.config.enableVersionControl) {
                documentData.versioning = {
                    version: {
                        major: 1,
                        minor: 0,
                        patch: 0
                    },
                    versionString: '1.0.0',
                    isLatest: true,
                    isDraft: documentData.lifecycle.status === DOCUMENT_STATUS.DRAFT,
                    versionHistory: [],
                    changeLog: []
                };
            }

            // Initialize access control
            if (!documentData.accessControl) {
                documentData.accessControl = {
                    owner: options.userId,
                    permissions: {
                        public: false,
                        inherited: true,
                        groups: [],
                        users: [],
                        roles: []
                    },
                    sharing: {
                        isShared: false,
                        sharedWith: [],
                        publicLink: {
                            enabled: false
                        }
                    },
                    restrictions: {
                        downloadDisabled: false,
                        printDisabled: false,
                        copyDisabled: false,
                        viewCount: 0
                    }
                };
            }

            // Initialize analytics
            if (!documentData.analytics) {
                documentData.analytics = {
                    views: {
                        total: 0,
                        unique: 0,
                        viewHistory: []
                    },
                    downloads: {
                        total: 0,
                        downloadHistory: []
                    },
                    shares: {
                        total: 0,
                        internal: 0,
                        external: 0
                    },
                    prints: {
                        total: 0
                    }
                };
            }

            // Set metadata
            documentData.metadata = {
                source: options.source || 'upload',
                uploadedBy: options.userId,
                uploadedAt: new Date(),
                flags: {
                    isFavorite: false,
                    isPinned: false,
                    isTemplate: false,
                    requiresAction: false
                }
            };

            documentData.isDeleted = false;

            // PHASE 6: DATABASE PERSISTENCE
            const ClientDocument = dbService.getModel('ClientDocument', 'customer');
            const newDocument = new ClientDocument(documentData);
            await newDocument.save();

            const duration = Date.now() - startTime;

            logger.info('Document created successfully', {
                operationId,
                documentId: newDocument.documentId,
                clientId: newDocument.clientId,
                tenantId: newDocument.tenantId.toString(),
                organizationId: newDocument.organizationId?.toString(),
                documentName: newDocument.documentInfo?.name,
                documentType: newDocument.documentInfo?.type,
                userId: options.userId,
                duration: `${duration}ms`
            });

            // PHASE 7: POST-CREATION ACTIVITIES
            setImmediate(async () => {
                try {
                    await this._handlePostDocumentCreation(newDocument, options);
                } catch (postError) {
                    logger.error('Post-creation activities failed (non-critical)', {
                        operationId,
                        documentId: newDocument.documentId,
                        error: postError.message,
                        stack: postError.stack
                    });
                }
            });

            return this._sanitizeDocumentOutput(newDocument);

        } catch (error) {
            const duration = Date.now() - startTime;

            logger.error('Document creation failed', {
                operationId,
                error: error.message,
                errorCode: error.code,
                stack: error.stack,
                clientId: documentData?.clientId,
                userId: options?.userId,
                duration: `${duration}ms`,
                context: error.context || {}
            });

            if (error instanceof AppError) {
                throw error;
            }

            if (error.name === 'ValidationError') {
                throw AppError.validation('Document validation failed', {
                    errors: Object.keys(error.errors).map(key => ({
                        field: key,
                        message: error.errors[key].message,
                        value: error.errors[key].value
                    }))
                });
            }

            throw AppError.internal('Document creation failed', {
                originalError: error.message,
                operationId
            });
        }
    }

    /**
     * Get document by ID with enterprise-grade access control
     */
    async getDocumentById(documentId, options = {}) {
        try {
            logger.info('Fetching document by ID', { documentId });

            if (!mongoose.Types.ObjectId.isValid(documentId)) {
                throw AppError.validation('Invalid document ID format', {
                    context: { documentId }
                });
            }

            const dbService = this._getDatabaseService();
            const ClientDocument = dbService.getModel('ClientDocument', 'customer');
            const Client = dbService.getModel('Client', 'customer');

            // Fetch document without population
            const document = await ClientDocument.findById(documentId).lean();

            if (!document) {
                throw AppError.notFound('Document not found', {
                    context: { documentId }
                });
            }

            if (document.isDeleted && !options.includeDeleted) {
                throw AppError.notFound('Document not found', {
                    context: { documentId }
                });
            }

            // Manually fetch client data if needed
            if (options.populate) {
                const client = await Client.findById(document.clientId)
                    .select('companyName clientCode tenantId organizationId')
                    .lean();

                if (client) {
                    document.clientId = client;
                }
            } else {
                const client = await Client.findById(document.clientId)
                    .select('tenantId organizationId')
                    .lean();

                if (client) {
                    document.clientId = client;
                }
            }

            // ACCESS CONTROL: Self-service check
            if (options.userClientId) {
                const clientIdString = document.clientId._id ?
                    document.clientId._id.toString() :
                    document.clientId.toString();

                if (clientIdString !== options.userClientId.toString()) {
                    throw AppError.forbidden('You can only access documents from your own account', {
                        context: {
                            documentClientId: clientIdString,
                            userClientId: options.userClientId
                        }
                    });
                }
            }
            // ACCESS CONTROL: Administrative tenant check
            else if (options.tenantId && !options.skipTenantCheck) {
                if (!mongoose.Types.ObjectId.isValid(options.tenantId)) {
                    throw AppError.validation('Valid tenant ID required in authentication context');
                }

                const documentTenantId = document.clientId.tenantId ?
                    document.clientId.tenantId.toString() :
                    document.tenantId.toString();

                if (documentTenantId !== options.tenantId.toString()) {
                    throw AppError.forbidden('Access denied to this document', {
                        context: {
                            documentTenantId: documentTenantId,
                            userTenantId: options.tenantId.toString()
                        }
                    });
                }
            }

            logger.info('Document fetched successfully', {
                documentId: document._id,
                clientId: document.clientId._id || document.clientId
            });

            // Track view
            if (options.trackView && options.userId) {
                setImmediate(async () => {
                    try {
                        await this._recordDocumentView(document._id, options.userId);
                    } catch (trackError) {
                        logger.error('Failed to track document view', {
                            error: trackError.message,
                            documentId: document._id
                        });
                    }
                });
            }

            return this._sanitizeDocumentOutput(document);

        } catch (error) {
            logger.error('Failed to fetch document', {
                error: error.message,
                documentId
            });
            throw error;
        }
    }

    /**
     * Get all documents for a client with access control
     */
    async getDocumentsByClient(clientId, options = {}) {
        try {
            logger.info('Fetching documents by client', { clientId });

            // Validate client ID format
            if (!mongoose.Types.ObjectId.isValid(clientId)) {
                throw AppError.validation('Invalid client ID format', {
                    context: { clientId }
                });
            }

            const dbService = this._getDatabaseService();
            const Client = dbService.getModel('Client', 'customer');
            const ClientDocument = dbService.getModel('ClientDocument', 'customer');

            // Verify client exists and get tenant information
            const client = await Client.findById(clientId)
                .select('tenantId organizationId companyName')
                .lean();

            if (!client) {
                throw AppError.notFound('Client not found', {
                    context: { clientId }
                });
            }

            // ACCESS CONTROL: Self-service check
            if (options.userClientId) {
                if (client._id.toString() !== options.userClientId.toString()) {
                    throw AppError.forbidden('You can only access documents from your own account', {
                        context: {
                            requestedClientId: clientId,
                            userClientId: options.userClientId
                        }
                    });
                }
            }
            // ACCESS CONTROL: Administrative tenant check
            else if (options.tenantId && !options.skipTenantCheck) {
                if (!mongoose.Types.ObjectId.isValid(options.tenantId)) {
                    throw AppError.validation('Valid tenant ID required in authentication context');
                }

                if (client.tenantId.toString() !== options.tenantId.toString()) {
                    throw AppError.forbidden('Access denied to this client', {
                        context: {
                            clientTenantId: client.tenantId.toString(),
                            userTenantId: options.tenantId.toString()
                        }
                    });
                }
            }

            // Build query
            const query = {
                clientId: clientId,
                isDeleted: { $ne: true }
            };

            // Filter by document type if provided
            if (options.type) {
                query['documentInfo.type'] = options.type;
            }

            // Filter by status if provided
            if (options.status) {
                query['lifecycle.status'] = options.status;
            }

            // Filter by project if provided
            if (options.projectId) {
                query.projectId = options.projectId;
            }

            // Filter by classification level if provided
            if (options.classificationLevel) {
                query['documentInfo.classification.level'] = options.classificationLevel;
            }

            // Build and execute query
            const sortField = options.sortBy || 'createdAt';
            const sortOrder = options.sortOrder === 'asc' ? 1 : -1;

            const documents = await ClientDocument.find(query)
                .sort({ [sortField]: sortOrder })
                .lean();

            logger.info('Documents fetched successfully', {
                clientId,
                count: documents.length
            });

            return documents.map(d => this._sanitizeDocumentOutput(d));

        } catch (error) {
            logger.error('Failed to fetch documents by client', {
                error: error.message,
                clientId
            });
            throw error;
        }
    }

    /**
     * Update document information with access control
     */
    // async updateDocument(documentId, updateData, options = {}) {
    //     try {
    //         logger.info('Updating document', {
    //             documentId,
    //             updateFields: Object.keys(updateData),
    //             userId: options.userId
    //         });

    //         // Validate document ID format
    //         if (!mongoose.Types.ObjectId.isValid(documentId)) {
    //             throw AppError.validation('Invalid document ID format', {
    //                 context: { documentId }
    //             });
    //         }

    //         // Validate update data
    //         await this._validateDocumentUpdateData(updateData);

    //         // Get existing document with access control
    //         const existingDocument = await this.getDocumentById(documentId, {
    //             tenantId: options.tenantId,
    //             userClientId: options.userClientId,
    //             skipTenantCheck: options.skipTenantCheck
    //         });

    //         const dbService = this._getDatabaseService();
    //         const ClientDocument = dbService.getModel('ClientDocument', 'customer');

    //         // Prepare update
    //         const update = {
    //             ...updateData
    //         };

    //         // Handle version increment if creating new version
    //         if (options.createNewVersion && this.config.enableVersionControl) {
    //             const currentVersion = existingDocument.versioning?.version || { major: 1, minor: 0, patch: 0 };
    //             update['versioning.version.minor'] = currentVersion.minor + 1;
    //             update['versioning.version.patch'] = 0;
    //             update['versioning.versionString'] = `${currentVersion.major}.${currentVersion.minor + 1}.0`;
    //         }

    //         // Perform update
    //         const updatedDocument = await ClientDocument.findByIdAndUpdate(
    //             documentId,
    //             { $set: update },
    //             { new: true, runValidators: true }
    //         ).lean();

    //         if (!updatedDocument) {
    //             throw AppError.notFound('Document not found for update');
    //         }

    //         logger.info('Document updated successfully', {
    //             documentId,
    //             userId: options.userId
    //         });

    //         // Track update event
    //         setImmediate(async () => {
    //             try {
    //                 await this._trackDocumentEvent(updatedDocument, 'document_updated', {
    //                     updatedFields: Object.keys(updateData),
    //                     userId: options.userId,
    //                     newVersion: options.createNewVersion
    //                 });
    //             } catch (trackError) {
    //                 logger.error('Failed to track update event', {
    //                     error: trackError.message,
    //                     documentId
    //                 });
    //             }
    //         });

    //         return this._sanitizeDocumentOutput(updatedDocument);

    //     } catch (error) {
    //         logger.error('Document update failed', {
    //             error: error.message,
    //             documentId
    //         });
    //         throw error;
    //     }
    // }

    async updateDocument(documentId, updateData, options = {}) {
        try {
            logger.info('Updating document', {
                documentId,
                updateFields: Object.keys(updateData),
                userId: options.userId
            });

            if (!mongoose.Types.ObjectId.isValid(documentId)) {
                throw AppError.validation('Invalid document ID format', {
                    context: { documentId }
                });
            }

            await this._validateDocumentUpdateData(updateData);

            // Get existing document with access control
            const existingDocument = await this.getDocumentById(documentId, {
                tenantId: options.tenantId,
                userClientId: options.userClientId,
                skipTenantCheck: options.skipTenantCheck
            });

            const dbService = this._getDatabaseService();
            const ClientDocument = dbService.getModel('ClientDocument', 'customer');

            // Flatten nested objects into dot notation
            const flattenUpdate = (obj, prefix = '') => {
                const flattened = {};

                for (const [key, value] of Object.entries(obj)) {
                    const newKey = prefix ? `${prefix}.${key}` : key;

                    if (value !== null && typeof value === 'object' && !Array.isArray(value) && !(value instanceof Date)) {
                        Object.assign(flattened, flattenUpdate(value, newKey));
                    } else {
                        flattened[newKey] = value;
                    }
                }

                return flattened;
            };

            const flattenedUpdate = flattenUpdate(updateData);

            // Handle version increment if creating new version
            if (options.createNewVersion && this.config.enableVersionControl) {
                const currentVersion = existingDocument.versioning?.version || { major: 1, minor: 0, patch: 0 };
                flattenedUpdate['versioning.version.minor'] = currentVersion.minor + 1;
                flattenedUpdate['versioning.version.patch'] = 0;
                flattenedUpdate['versioning.versionString'] = `${currentVersion.major}.${currentVersion.minor + 1}.0`;
            }

            // Perform update with flattened fields
            const updatedDocument = await ClientDocument.findByIdAndUpdate(
                documentId,
                { $set: flattenedUpdate },
                { new: true, runValidators: true }
            ).lean();

            if (!updatedDocument) {
                throw AppError.notFound('Document not found for update');
            }

            logger.info('Document updated successfully', {
                documentId,
                userId: options.userId
            });

            // Track update event
            setImmediate(async () => {
                try {
                    await this._trackDocumentEvent(updatedDocument, 'document_updated', {
                        updatedFields: Object.keys(updateData),
                        userId: options.userId,
                        newVersion: options.createNewVersion
                    });
                } catch (trackError) {
                    logger.error('Failed to track update event', {
                        error: trackError.message,
                        documentId
                    });
                }
            });

            return this._sanitizeDocumentOutput(updatedDocument);

        } catch (error) {
            logger.error('Document update failed', {
                error: error.message,
                documentId
            });
            throw error;
        }
    }

    /**
     * Delete/archive document with access control
     */
    async deleteDocument(documentId, options = {}) {
        try {
            logger.info('Deleting document', {
                documentId,
                softDelete: options.softDelete,
                userId: options.userId
            });

            // Validate document ID format
            if (!mongoose.Types.ObjectId.isValid(documentId)) {
                throw AppError.validation('Invalid document ID format', {
                    context: { documentId }
                });
            }

            // Get existing document with access control
            const existingDocument = await this.getDocumentById(documentId, {
                tenantId: options.tenantId,
                userClientId: options.userClientId,
                skipTenantCheck: options.skipTenantCheck
            });

            const dbService = this._getDatabaseService();
            const ClientDocument = dbService.getModel('ClientDocument', 'customer');

            let result;

            if (options.softDelete !== false) {
                // Soft delete - mark as deleted
                result = await ClientDocument.findByIdAndUpdate(
                    documentId,
                    {
                        $set: {
                            isDeleted: true,
                            'lifecycle.status': DOCUMENT_STATUS.ARCHIVED,
                            deletedAt: new Date(),
                            deletedBy: options.userId
                        }
                    },
                    { new: true }
                ).lean();
            } else {
                // Hard delete - only if authorized
                if (!options.forceDelete) {
                    throw AppError.forbidden('Hard delete requires force flag');
                }
                result = await ClientDocument.findByIdAndDelete(documentId).lean();
            }

            logger.info('Document deleted successfully', {
                documentId,
                softDelete: options.softDelete !== false,
                userId: options.userId
            });

            // Track deletion event
            setImmediate(async () => {
                try {
                    await this._trackDocumentEvent(existingDocument, 'document_deleted', {
                        softDelete: options.softDelete !== false,
                        userId: options.userId
                    });
                } catch (trackError) {
                    logger.error('Failed to track deletion event', {
                        error: trackError.message,
                        documentId
                    });
                }
            });

            return {
                success: true,
                documentId,
                deletionType: options.softDelete !== false ? 'soft' : 'hard'
            };

        } catch (error) {
            logger.error('Document deletion failed', {
                error: error.message,
                documentId
            });
            throw error;
        }
    }

    /**
     * Download document with access control
     */
    async downloadDocument(documentId, options = {}) {
        try {
            logger.info('Downloading document', {
                documentId,
                userId: options.userId
            });

            // Get document with access control
            const document = await this.getDocumentById(documentId, {
                tenantId: options.tenantId,
                userClientId: options.userClientId,
                skipTenantCheck: options.skipTenantCheck
            });

            // Check download restrictions
            if (document.accessControl?.restrictions?.downloadDisabled) {
                throw AppError.forbidden('Download is disabled for this document');
            }

            // Track download
            setImmediate(async () => {
                try {
                    await this._recordDocumentDownload(document._id, options.userId);
                } catch (trackError) {
                    logger.error('Failed to track document download', {
                        error: trackError.message,
                        documentId
                    });
                }
            });

            return {
                document: this._sanitizeDocumentOutput(document),
                downloadUrl: document.storage?.url,
                fileName: document.fileDetails?.originalName || document.documentInfo?.name
            };

        } catch (error) {
            logger.error('Document download failed', {
                error: error.message,
                documentId
            });
            throw error;
        }
    }

    // ============= VALIDATION METHODS =============

    /**
     * Validate document data with enhanced error reporting
     * @private
     */
    async _validateDocumentData(documentData) {
        const errors = [];

        logger.debug('Starting document data validation', {
            hasClientId: !!documentData.clientId,
            hasDocumentInfo: !!documentData.documentInfo
        });

        // Required fields
        if (!documentData.clientId) {
            errors.push({ field: 'clientId', message: 'Client ID is required' });
        }

        if (!documentData.documentInfo?.name) {
            errors.push({ field: 'documentInfo.name', message: 'Document name is required' });
        }

        if (documentData.documentInfo?.name && documentData.documentInfo.name.length > 500) {
            errors.push({ field: 'documentInfo.name', message: 'Document name exceeds maximum length of 500 characters' });
        }

        if (!documentData.documentInfo?.type) {
            errors.push({ field: 'documentInfo.type', message: 'Document type is required' });
        }

        // Validate document type
        if (documentData.documentInfo?.type) {
            const validTypes = Object.values(DOCUMENT_TYPES);
            if (!validTypes.includes(documentData.documentInfo.type)) {
                errors.push({
                    field: 'documentInfo.type',
                    message: `Invalid document type. Must be one of: ${validTypes.join(', ')}`
                });
            }
        }

        if (errors.length > 0) {
            logger.error('Document validation failed with errors', {
                errors: errors,
                documentData: {
                    clientId: documentData.clientId,
                    documentName: documentData.documentInfo?.name,
                    documentType: documentData.documentInfo?.type
                }
            });

            throw AppError.validation('Document validation failed', { errors });
        }

        logger.debug('Document validation passed successfully');
    }

    /**
     * Validate document update data
     * @private
     */
    async _validateDocumentUpdateData(updateData) {
        const errors = [];

        // Cannot update immutable fields
        const immutableFields = ['documentId', 'clientId', 'tenantId', 'organizationId', 'metadata.uploadedAt', 'metadata.uploadedBy'];
        for (const field of immutableFields) {
            if (updateData[field] !== undefined) {
                errors.push({ field, message: `${field} cannot be updated` });
            }
        }

        // Validate document name length if provided
        if (updateData.documentInfo?.name && updateData.documentInfo.name.length > 500) {
            errors.push({ field: 'documentInfo.name', message: 'Document name exceeds maximum length of 500 characters' });
        }

        if (errors.length > 0) {
            throw AppError.validation('Document update validation failed', { errors });
        }
    }

    /**
     * Validate file type
     * @private
     */
    async _validateFileType(fileExtension) {
        const ext = fileExtension.toLowerCase().replace('.', '');
        if (!this.config.allowedFileTypes.includes(ext)) {
            throw AppError.validation(`File type .${ext} is not allowed`, {
                context: {
                    allowedTypes: this.config.allowedFileTypes
                }
            });
        }
    }

    /**
     * Validate file size
     * @private
     */
    async _validateFileSize(size) {
        if (size > this.config.maxDocumentSize) {
            const maxSizeMB = (this.config.maxDocumentSize / (1024 * 1024)).toFixed(2);
            const fileSizeMB = (size / (1024 * 1024)).toFixed(2);
            throw AppError.validation(`File size (${fileSizeMB}MB) exceeds maximum allowed (${maxSizeMB}MB)`, {
                context: {
                    fileSize: size,
                    maxSize: this.config.maxDocumentSize,
                    fileSizeMB,
                    maxSizeMB
                }
            });
        }
    }

    /**
     * Check document limit for client
     * @private
     */
    async _checkDocumentLimit(clientId) {
        const dbService = this._getDatabaseService();
        const ClientDocument = dbService.getModel('ClientDocument', 'customer');

        const count = await ClientDocument.countDocuments({
            clientId: clientId,
            isDeleted: { $ne: true }
        });

        if (count >= this.config.maxDocumentsPerClient) {
            throw AppError.validation('Document limit reached for this client', {
                context: {
                    currentCount: count,
                    maxAllowed: this.config.maxDocumentsPerClient
                }
            });
        }
    }

    // ============= HELPER METHODS =============

    /**
     * Generate unique document ID
     * @private
     */
    async _generateDocumentId() {
        const prefix = 'DOC';
        const timestamp = Date.now().toString(36).toUpperCase();
        const random = crypto.randomBytes(4).toString('hex').toUpperCase();

        const id = `${prefix}-${timestamp}${random}`;  // Creates: DOC-XXXXXXXXXXXX (no middle dash)

        // Verify uniqueness
        const dbService = this._getDatabaseService();
        const ClientDocument = dbService.getModel('ClientDocument', 'customer');
        const existing = await ClientDocument.findOne({ documentId: id });

        if (existing) {
            return this._generateDocumentId();
        }

        return id;
    }

    /**
     * Record document view
     * @private
     */
    async _recordDocumentView(documentId, userId) {
        try {
            const dbService = this._getDatabaseService();
            const ClientDocument = dbService.getModel('ClientDocument', 'customer');

            await ClientDocument.findByIdAndUpdate(
                documentId,
                {
                    $inc: {
                        'analytics.views.total': 1
                    },
                    $set: {
                        'analytics.views.lastViewed': new Date()
                    },
                    $push: {
                        'analytics.views.viewHistory': {
                            $each: [{
                                viewedBy: userId,
                                viewedAt: new Date()
                            }],
                            $slice: -100 // Keep only last 100 views
                        }
                    }
                }
            );

            logger.debug('Document view recorded', { documentId, userId });
        } catch (error) {
            logger.error('Failed to record document view', {
                error: error.message,
                documentId,
                userId
            });
        }
    }

    /**
     * Record document download
     * @private
     */
    async _recordDocumentDownload(documentId, userId) {
        try {
            const dbService = this._getDatabaseService();
            const ClientDocument = dbService.getModel('ClientDocument', 'customer');

            await ClientDocument.findByIdAndUpdate(
                documentId,
                {
                    $inc: {
                        'analytics.downloads.total': 1
                    },
                    $set: {
                        'analytics.downloads.lastDownloaded': new Date()
                    },
                    $push: {
                        'analytics.downloads.downloadHistory': {
                            $each: [{
                                downloadedBy: userId,
                                downloadedAt: new Date()
                            }],
                            $slice: -100 // Keep only last 100 downloads
                        }
                    }
                }
            );

            logger.debug('Document download recorded', { documentId, userId });
        } catch (error) {
            logger.error('Failed to record document download', {
                error: error.message,
                documentId,
                userId
            });
        }
    }

    /**
     * Handle post-document creation activities
     * @private
     */
    async _handlePostDocumentCreation(document, options) {
        try {
            // Track creation event
            await this._trackDocumentEvent(document, 'document_created', {
                userId: options.userId,
                source: options.source || 'upload'
            });

        } catch (error) {
            logger.error('Post-document creation activities failed (non-blocking)', {
                error: error.message,
                documentId: document.documentId
            });
        }
    }

    /**
     * Track document event
     * @private
     */
    async _trackDocumentEvent(document, eventType, data) {
        try {
            if (typeof this.analyticsService.trackEvent === 'function') {
                await this.analyticsService.trackEvent({
                    type: eventType,
                    documentId: document._id || document.id,
                    clientId: document.clientId,
                    data: data
                });
            }
        } catch (error) {
            logger.error('Failed to track document event', {
                error: error.message,
                eventType,
                documentId: document._id || document.id
            });
        }
    }

    /**
     * Sanitize document output
     * @private
     */
    _sanitizeDocumentOutput(document) {
        if (!document) return null;

        const documentObject = document.toObject ? document.toObject() : document;

        // Remove sensitive and internal fields
        delete documentObject.__v;
        delete documentObject.searchTokens;
        delete documentObject.storage?.signedUrl;
        delete documentObject.contentExtraction?.searchableContent;
        delete documentObject.contentExtraction?.ocr?.text;
        delete documentObject.contentExtraction?.textContent?.content;
        delete documentObject.signatures?.signatories?.verificationCode;
        delete documentObject.accessControl?.sharing?.publicLink?.password;

        return documentObject;
    }
}

module.exports = new ClientDocumentService();