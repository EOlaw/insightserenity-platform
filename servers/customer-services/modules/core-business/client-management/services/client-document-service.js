/**
 * @fileoverview Client Document Management Service
 * @module servers/customer-services/modules/core-business/client-management/services/client-document-service
 * @description Comprehensive service for managing client documents including versioning, access control, and lifecycle management
 */

const { AppError } = require('../../../../../../shared/lib/utils/app-error');
const logger = require('../../../../../../shared/lib/utils/logger').createLogger({
    serviceName: 'client-document-service'
});
const validator = require('validator');
const crypto = require('crypto');
const path = require('path');

// Import secure database service
const database = require('../../../../../../shared/lib/database');

// Import business services
const NotificationService = require('../../notifications/services/notification-service');
const AnalyticsService = require('../../analytics/services/analytics-service');

/**
 * Document Type Constants
 */
const DOCUMENT_TYPES = {
    CONTRACT: 'contract',
    PROPOSAL: 'proposal',
    INVOICE: 'invoice',
    REPORT: 'report',
    PRESENTATION: 'presentation',
    AGREEMENT: 'agreement',
    SOW: 'statement_of_work',
    NDA: 'nda',
    MSA: 'master_service_agreement',
    OTHER: 'other'
};

/**
 * Document Status Constants
 */
const DOCUMENT_STATUS = {
    DRAFT: 'draft',
    IN_REVIEW: 'in_review',
    APPROVED: 'approved',
    ACTIVE: 'active',
    EXPIRED: 'expired',
    ARCHIVED: 'archived',
    DELETED: 'deleted'
};

/**
 * Access Level Constants
 */
const ACCESS_LEVELS = {
    PUBLIC: 'public',
    INTERNAL: 'internal',
    CONFIDENTIAL: 'confidential',
    RESTRICTED: 'restricted',
    HIGHLY_CONFIDENTIAL: 'highly_confidential'
};

/**
 * Client Document Management Service
 * @class ClientDocumentService
 */
class ClientDocumentService {
    constructor() {
        this._dbService = null;
        this.notificationService = NotificationService;
        this.analyticsService = AnalyticsService;

        // Configuration
        this.config = {
            companyTenantId: process.env.COMPANY_TENANT_ID || 'default',
            storageBasePath: process.env.DOCUMENT_STORAGE_PATH || '/storage/documents',
            autoGenerateDocumentId: process.env.AUTO_GENERATE_DOCUMENT_ID !== 'false',
            maxDocumentSize: parseInt(process.env.MAX_DOCUMENT_SIZE, 10) || 104857600, // 100MB
            enableVersionControl: process.env.ENABLE_VERSION_CONTROL !== 'false',
            maxVersionsToKeep: parseInt(process.env.MAX_VERSIONS_TO_KEEP, 10) || 10,
            requireApprovalForPublish: process.env.REQUIRE_DOCUMENT_APPROVAL === 'true',
            allowedFileTypes: (process.env.ALLOWED_DOCUMENT_TYPES || 'pdf,doc,docx,xls,xlsx,ppt,pptx,txt,csv').split(',')
        };
    }

    /**
     * Get database service instance
     * @private
     * @returns {Object} Database service
     */
    _getDatabaseService() {
        if (!this._dbService) {
            this._dbService = database;
        }
        return this._dbService;
    }

    // ============= DOCUMENT CREATION & UPLOAD =============

    /**
     * Create a new document record
     * @param {Object} documentData - Document information
     * @param {Object} options - Additional options
     * @returns {Promise<Object>} Created document
     */
    async createDocument(documentData, options = {}) {
        try {
            logger.info('Starting document creation', {
                clientId: documentData.clientId,
                documentName: documentData.documentInfo?.name,
                type: documentData.documentInfo?.type
            });

            // Validate document data
            await this._validateDocumentData(documentData);

            // Verify client exists
            await this._verifyClientExists(documentData.clientId, options.tenantId);

            // Check file type if file info provided
            if (documentData.file?.originalName) {
                await this._validateFileType(documentData.file.originalName);
            }

            // Check file size if provided
            if (documentData.file?.size) {
                await this._validateFileSize(documentData.file.size);
            }

            // Generate document ID if not provided
            if (!documentData.documentId && this.config.autoGenerateDocumentId) {
                documentData.documentId = await this._generateDocumentId();
            }

            // Set default values
            documentData.tenantId = options.tenantId || this.config.companyTenantId;
            documentData.organizationId = options.organizationId || documentData.organizationId;
            documentData.status = documentData.status || DOCUMENT_STATUS.DRAFT;

            // Initialize version control
            if (this.config.enableVersionControl) {
                documentData.version = {
                    current: 1,
                    major: 1,
                    minor: 0,
                    patch: 0
                };
            }

            // Initialize access control
            if (!documentData.access) {
                documentData.access = {
                    level: ACCESS_LEVELS.INTERNAL,
                    allowedUsers: [],
                    allowedRoles: []
                };
            }

            // Initialize metadata
            documentData.metadata = {
                createdBy: options.userId,
                createdAt: new Date(),
                uploadedFrom: options.uploadSource || 'web',
                fileHash: documentData.file?.hash || null
            };

            const dbService = this._getDatabaseService();
            const ClientDocument = await dbService.getModel('ClientDocument', 'customer');

            // Create document
            const newDocument = new ClientDocument(documentData);
            await newDocument.save();

            logger.info('Document created successfully', {
                documentId: newDocument.documentId,
                clientId: newDocument.clientId,
                name: newDocument.documentInfo?.name
            });

            // Post-creation activities
            await this._handlePostDocumentCreation(newDocument, options);

            return this._sanitizeDocumentOutput(newDocument);

        } catch (error) {
            logger.error('Document creation failed', {
                error: error.message,
                stack: error.stack,
                clientId: documentData?.clientId
            });
            throw error;
        }
    }

    /**
     * Get document by ID
     * @param {string} documentId - Document ID or MongoDB ObjectId
     * @param {Object} options - Query options
     * @returns {Promise<Object>} Document data
     */
    async getDocumentById(documentId, options = {}) {
        try {
            logger.info('Fetching document by ID', { documentId });

            const dbService = this._getDatabaseService();
            const ClientDocument = await dbService.getModel('ClientDocument', 'customer');

            // Determine if searching by MongoDB ID or documentId field
            let query;
            if (documentId.match(/^[0-9a-fA-F]{24}$/)) {
                query = ClientDocument.findById(documentId);
            } else {
                query = ClientDocument.findOne({ documentId: documentId.toUpperCase() });
            }

            // Apply population if requested
            if (options.populate) {
                query = query.populate('clientId projectId engagementId metadata.createdBy');
            }

            const document = await query.exec();

            if (!document) {
                throw AppError.notFound('Document not found', {
                    context: { documentId }
                });
            }

            // Check tenant access
            if (options.tenantId && document.tenantId.toString() !== options.tenantId) {
                throw AppError.forbidden('Access denied to this document');
            }

            // Check user access permissions
            if (options.userId && !await this._checkDocumentAccess(document, options.userId)) {
                throw AppError.forbidden('Insufficient permissions to access this document');
            }

            // Track document access
            await this._trackDocumentAccess(document._id, options.userId);

            return this._sanitizeDocumentOutput(document);

        } catch (error) {
            logger.error('Failed to fetch document', {
                error: error.message,
                documentId
            });
            throw error;
        }
    }

    /**
     * Get all documents for a client
     * @param {string} clientId - Client ID
     * @param {Object} options - Query options
     * @returns {Promise<Array>} List of documents
     */
    async getDocumentsByClient(clientId, options = {}) {
        try {
            logger.info('Fetching documents by client', { clientId });

            const dbService = this._getDatabaseService();
            const ClientDocument = await dbService.getModel('ClientDocument', 'customer');

            const query = {
                clientId: clientId,
                tenantId: options.tenantId || this.config.companyTenantId,
                'metadata.isDeleted': { $ne: true }
            };

            // Filter by document type if provided
            if (options.type) {
                query['documentInfo.type'] = options.type;
            }

            // Filter by status if provided
            if (options.status) {
                query.status = options.status;
            }

            // Filter by project if provided
            if (options.projectId) {
                query.projectId = options.projectId;
            }

            let documentQuery = ClientDocument.find(query);

            // Apply sorting
            const sortField = options.sortBy || 'metadata.createdAt';
            const sortOrder = options.sortOrder === 'asc' ? 1 : -1;
            documentQuery = documentQuery.sort({ [sortField]: sortOrder });

            // Apply pagination
            if (options.limit) {
                const page = parseInt(options.page, 10) || 1;
                const limit = parseInt(options.limit, 10);
                const skip = (page - 1) * limit;
                documentQuery = documentQuery.skip(skip).limit(limit);
            }

            const documents = await documentQuery.lean().exec();

            logger.info('Documents fetched successfully', {
                clientId,
                count: documents.length
            });

            return documents.map(d => this._sanitizeDocumentOutput(d));

        } catch (error) {
            logger.error('Failed to fetch documents by client', {
                error: error.message,
                clientId
            });
            throw error;
        }
    }

    /**
     * Update document information
     * @param {string} documentId - Document ID
     * @param {Object} updateData - Data to update
     * @param {Object} options - Update options
     * @returns {Promise<Object>} Updated document
     */
    async updateDocument(documentId, updateData, options = {}) {
        try {
            logger.info('Updating document', {
                documentId,
                updateFields: Object.keys(updateData)
            });

            // Validate update data
            await this._validateDocumentUpdateData(updateData);

            // Get existing document
            const document = await this.getDocumentById(documentId, { 
                tenantId: options.tenantId,
                userId: options.userId
            });

            const dbService = this._getDatabaseService();
            const ClientDocument = await dbService.getModel('ClientDocument', 'customer');

            // Prepare update
            const update = {
                ...updateData,
                'metadata.updatedBy': options.userId,
                'metadata.lastModified': new Date()
            };

            // Handle version increment if document content changed
            if (options.createNewVersion && this.config.enableVersionControl) {
                update['version.current'] = document.version.current + 1;
                update['version.minor'] = document.version.minor + 1;
                
                // Archive current version
                await this._archiveDocumentVersion(document);
            }

            // Perform update
            const updatedDocument = await ClientDocument.findOneAndUpdate(
                { documentId: documentId.toUpperCase() },
                { $set: update },
                { new: true, runValidators: true }
            );

            if (!updatedDocument) {
                throw AppError.notFound('Document not found for update');
            }

            logger.info('Document updated successfully', {
                documentId,
                name: updatedDocument.documentInfo?.name
            });

            // Track update event
            await this._trackDocumentEvent(updatedDocument, 'document_updated', {
                updatedFields: Object.keys(updateData),
                userId: options.userId,
                newVersion: options.createNewVersion
            });

            return this._sanitizeDocumentOutput(updatedDocument);

        } catch (error) {
            logger.error('Document update failed', {
                error: error.message,
                documentId
            });
            throw error;
        }
    }

    /**
     * Delete/archive document
     * @param {string} documentId - Document ID
     * @param {Object} options - Deletion options
     * @returns {Promise<Object>} Deletion result
     */
    async deleteDocument(documentId, options = {}) {
        try {
            logger.info('Deleting document', { documentId, softDelete: options.softDelete });

            const document = await this.getDocumentById(documentId, { 
                tenantId: options.tenantId,
                userId: options.userId
            });

            const dbService = this._getDatabaseService();
            const ClientDocument = await dbService.getModel('ClientDocument', 'customer');

            let result;

            if (options.softDelete !== false) {
                // Soft delete - mark as archived
                result = await ClientDocument.findOneAndUpdate(
                    { documentId: documentId.toUpperCase() },
                    {
                        $set: {
                            status: DOCUMENT_STATUS.ARCHIVED,
                            'metadata.deletedAt': new Date(),
                            'metadata.deletedBy': options.userId,
                            'metadata.isDeleted': true
                        }
                    },
                    { new: true }
                );
            } else {
                // Hard delete - only if authorized
                if (!options.forceDelete) {
                    throw AppError.forbidden('Hard delete requires force flag');
                }
                result = await ClientDocument.findOneAndDelete({ documentId: documentId.toUpperCase() });
            }

            logger.info('Document deleted successfully', {
                documentId,
                softDelete: options.softDelete !== false
            });

            // Track deletion event
            await this._trackDocumentEvent(document, 'document_deleted', {
                softDelete: options.softDelete !== false,
                userId: options.userId
            });

            return {
                success: true,
                documentId,
                deletionType: options.softDelete !== false ? 'soft' : 'hard'
            };

        } catch (error) {
            logger.error('Document deletion failed', {
                error: error.message,
                documentId
            });
            throw error;
        }
    }

    /**
     * Search documents with filters
     * @param {Object} filters - Search filters
     * @param {Object} options - Query options
     * @returns {Promise<Object>} Search results
     */
    async searchDocuments(filters = {}, options = {}) {
        try {
            logger.info('Searching documents', { filters });

            const dbService = this._getDatabaseService();
            const ClientDocument = await dbService.getModel('ClientDocument', 'customer');

            // Build query
            const query = {
                tenantId: options.tenantId || this.config.companyTenantId,
                'metadata.isDeleted': { $ne: true }
            };

            // Apply filters
            if (filters.clientId) {
                query.clientId = filters.clientId;
            }

            if (filters.type) {
                query['documentInfo.type'] = filters.type;
            }

            if (filters.status) {
                query.status = filters.status;
            }

            if (filters.accessLevel) {
                query['access.level'] = filters.accessLevel;
            }

            if (filters.search) {
                query.$or = [
                    { 'documentInfo.name': { $regex: filters.search, $options: 'i' } },
                    { 'documentInfo.description': { $regex: filters.search, $options: 'i' } },
                    { documentId: { $regex: filters.search, $options: 'i' } },
                    { 'documentInfo.tags': { $regex: filters.search, $options: 'i' } }
                ];
            }

            if (filters.dateFrom || filters.dateTo) {
                query['metadata.createdAt'] = {};
                if (filters.dateFrom) query['metadata.createdAt'].$gte = new Date(filters.dateFrom);
                if (filters.dateTo) query['metadata.createdAt'].$lte = new Date(filters.dateTo);
            }

            // Pagination
            const page = parseInt(options.page, 10) || 1;
            const limit = parseInt(options.limit, 10) || 20;
            const skip = (page - 1) * limit;

            // Sorting
            const sortField = options.sortBy || 'metadata.createdAt';
            const sortOrder = options.sortOrder === 'asc' ? 1 : -1;
            const sort = { [sortField]: sortOrder };

            // Execute query
            const [documents, total] = await Promise.all([
                ClientDocument.find(query)
                    .sort(sort)
                    .skip(skip)
                    .limit(limit)
                    .populate('clientId', 'companyName clientCode')
                    .populate('metadata.createdBy', 'firstName lastName')
                    .lean()
                    .exec(),
                ClientDocument.countDocuments(query)
            ]);

            logger.info('Document search completed', {
                total,
                returned: documents.length,
                page
            });

            return {
                documents: documents.map(d => this._sanitizeDocumentOutput(d)),
                pagination: {
                    total,
                    page,
                    limit,
                    totalPages: Math.ceil(total / limit),
                    hasNext: page < Math.ceil(total / limit),
                    hasPrev: page > 1
                }
            };

        } catch (error) {
            logger.error('Document search failed', {
                error: error.message,
                filters
            });
            throw error;
        }
    }

    /**
     * Share document with users
     * @param {string} documentId - Document ID
     * @param {Array} userIds - User IDs to share with
     * @param {Object} options - Share options
     * @returns {Promise<Object>} Updated document
     */
    async shareDocument(documentId, userIds, options = {}) {
        try {
            logger.info('Sharing document', {
                documentId,
                userCount: userIds.length
            });

            const document = await this.getDocumentById(documentId, { 
                tenantId: options.tenantId,
                userId: options.userId
            });

            const dbService = this._getDatabaseService();
            const ClientDocument = await dbService.getModel('ClientDocument', 'customer');

            // Add users to allowed list
            const updatedDocument = await ClientDocument.findOneAndUpdate(
                { documentId: documentId.toUpperCase() },
                {
                    $addToSet: { 'access.allowedUsers': { $each: userIds } },
                    $set: {
                        'metadata.lastShared': new Date(),
                        'metadata.lastSharedBy': options.userId
                    }
                },
                { new: true }
            );

            logger.info('Document shared successfully', { documentId });

            // Track share event
            await this._trackDocumentEvent(updatedDocument, 'document_shared', {
                sharedWith: userIds,
                userId: options.userId
            });

            // Send notifications to shared users
            if (options.notify !== false) {
                await this._notifyDocumentShare(updatedDocument, userIds, options.userId);
            }

            return this._sanitizeDocumentOutput(updatedDocument);

        } catch (error) {
            logger.error('Document sharing failed', {
                error: error.message,
                documentId
            });
            throw error;
        }
    }

    // ============= VALIDATION METHODS =============

    /**
     * Validate document data
     * @private
     */
    async _validateDocumentData(documentData) {
        const errors = [];

        // Required fields
        if (!documentData.clientId) {
            errors.push({ field: 'clientId', message: 'Client ID is required' });
        }

        if (!documentData.documentInfo?.name) {
            errors.push({ field: 'documentInfo.name', message: 'Document name is required' });
        }

        if (documentData.documentInfo?.name && documentData.documentInfo.name.length > 500) {
            errors.push({ field: 'documentInfo.name', message: 'Document name too long' });
        }

        if (!documentData.documentInfo?.type) {
            errors.push({ field: 'documentInfo.type', message: 'Document type is required' });
        }

        if (errors.length > 0) {
            throw AppError.validation('Document validation failed', { errors });
        }
    }

    /**
     * Validate document update data
     * @private
     */
    async _validateDocumentUpdateData(updateData) {
        const errors = [];

        // Cannot update immutable fields
        const immutableFields = ['documentId', 'clientId', 'tenantId'];
        for (const field of immutableFields) {
            if (updateData[field] !== undefined) {
                errors.push({ field, message: `${field} cannot be updated` });
            }
        }

        if (errors.length > 0) {
            throw AppError.validation('Document update validation failed', { errors });
        }
    }

    /**
     * Validate file type
     * @private
     */
    async _validateFileType(filename) {
        const ext = path.extname(filename).toLowerCase().replace('.', '');
        if (!this.config.allowedFileTypes.includes(ext)) {
            throw AppError.validation(`File type .${ext} is not allowed`, {
                context: {
                    allowedTypes: this.config.allowedFileTypes
                }
            });
        }
    }

    /**
     * Validate file size
     * @private
     */
    async _validateFileSize(size) {
        if (size > this.config.maxDocumentSize) {
            throw AppError.validation('File size exceeds maximum allowed', {
                context: {
                    fileSize: size,
                    maxSize: this.config.maxDocumentSize
                }
            });
        }
    }

    /**
     * Verify client exists
     * @private
     */
    async _verifyClientExists(clientId, tenantId) {
        const dbService = this._getDatabaseService();
        const Client = await dbService.getModel('Client', 'customer');

        const client = await Client.findById(clientId);

        if (!client) {
            throw AppError.notFound('Client not found', {
                context: { clientId }
            });
        }

        if (tenantId && client.tenantId.toString() !== tenantId) {
            throw AppError.forbidden('Access denied to this client');
        }
    }

    /**
     * Check document access permissions
     * @private
     */
    async _checkDocumentAccess(document, userId) {
        // Public documents are accessible to all
        if (document.access.level === ACCESS_LEVELS.PUBLIC) {
            return true;
        }

        // Check if user is in allowed list
        if (document.access.allowedUsers && document.access.allowedUsers.includes(userId)) {
            return true;
        }

        // Check if user is creator
        if (document.metadata.createdBy && document.metadata.createdBy.toString() === userId) {
            return true;
        }

        return false;
    }

    // ============= HELPER METHODS =============

    /**
     * Generate unique document ID
     * @private
     */
    async _generateDocumentId() {
        const prefix = 'DOC';
        const timestamp = Date.now().toString(36).toUpperCase();
        const random = crypto.randomBytes(4).toString('hex').toUpperCase();
        
        const id = `${prefix}-${timestamp}${random}`;

        // Verify uniqueness
        const dbService = this._getDatabaseService();
        const ClientDocument = await dbService.getModel('ClientDocument', 'customer');
        const existing = await ClientDocument.findOne({ documentId: id });

        if (existing) {
            return this._generateDocumentId();
        }

        return id;
    }

    /**
     * Archive document version
     * @private
     */
    async _archiveDocumentVersion(document) {
        logger.info('Archiving document version', {
            documentId: document.documentId,
            version: document.version.current
        });
        // Placeholder for version archival logic
    }

    /**
     * Track document access
     * @private
     */
    async _trackDocumentAccess(documentId, userId) {
        try {
            const dbService = this._getDatabaseService();
            const ClientDocument = await dbService.getModel('ClientDocument', 'customer');

            await ClientDocument.findByIdAndUpdate(
                documentId,
                {
                    $inc: { 'analytics.viewCount': 1 },
                    $set: { 'analytics.lastViewedAt': new Date() }
                }
            );
        } catch (error) {
            logger.error('Failed to track document access', { error: error.message });
        }
    }

    /**
     * Handle post-document creation activities
     * @private
     */
    async _handlePostDocumentCreation(document, options) {
        try {
            // Track creation event
            await this._trackDocumentEvent(document, 'document_created', {
                userId: options.userId,
                source: options.uploadSource || 'web'
            });

        } catch (error) {
            logger.error('Post-document creation activities failed (non-blocking)', {
                error: error.message,
                documentId: document.documentId
            });
        }
    }

    /**
     * Notify users about document share
     * @private
     */
    async _notifyDocumentShare(document, userIds, sharedBy) {
        try {
            if (typeof this.notificationService.sendNotification === 'function') {
                for (const userId of userIds) {
                    await this.notificationService.sendNotification({
                        type: 'document_shared',
                        recipient: userId,
                        data: {
                            documentName: document.documentInfo.name,
                            documentId: document.documentId,
                            sharedBy: sharedBy
                        }
                    });
                }
            }
        } catch (error) {
            logger.error('Failed to send document share notifications', { error: error.message });
        }
    }

    /**
     * Track document event
     * @private
     */
    async _trackDocumentEvent(document, eventType, data) {
        try {
            if (typeof this.analyticsService.trackEvent === 'function') {
                await this.analyticsService.trackEvent({
                    type: eventType,
                    documentId: document._id || document.id,
                    clientId: document.clientId,
                    data: data
                });
            }
        } catch (error) {
            logger.error('Failed to track document event', { error: error.message });
        }
    }

    /**
     * Sanitize document output
     * @private
     */
    _sanitizeDocumentOutput(document) {
        if (!document) return null;

        const documentObject = document.toObject ? document.toObject() : document;

        // Remove sensitive fields
        delete documentObject.__v;
        delete documentObject.metadata?.deletedAt;
        delete documentObject.metadata?.deletedBy;
        delete documentObject.file?.storageKey;
        delete documentObject.security?.encryptionKey;

        return documentObject;
    }
}

module.exports = new ClientDocumentService();