/**
 * @fileoverview Client Document Management Service
 * @module servers/customer-services/modules/core-business/client-management/services/client-document-service
 * @description Comprehensive service for managing client documents with enterprise-grade access control and lifecycle management
 */

const { AppError } = require('../../../../../../shared/lib/utils/app-error');
const logger = require('../../../../../../shared/lib/utils/logger').createLogger({
    serviceName: 'client-document-service'
});
const validator = require('validator');
const crypto = require('crypto');
const path = require('path');
const mongoose = require('mongoose');

// Import secure database service
const database = require('../../../../../../shared/lib/database');

// Import business services
const NotificationService = require('../../notifications/services/notification-service');
const AnalyticsService = require('../../analytics/services/analytics-service');
const { Client } = require('../../../../../../shared/lib/database/models/customer-services/core-business/client-management/client-model');
const S3UrlHelper = require('../../../../../../shared/lib/utils/helpers/s3-url-helper');

const { S3Client, GetObjectCommand } = require('@aws-sdk/client-s3');
const { getSignedUrl } = require('@aws-sdk/s3-request-presigner');

// S3 Client for generating pre-signed URLs
const s3Client = new S3Client({
    region: process.env.AWS_DEFAULT_REGION || 'ap-southeast-1',
    credentials: {
        accessKeyId: process.env.AWS_ACCESS_KEY_ID,
        secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY
    }
});

/**
 * Document Type Constants
 */
const DOCUMENT_TYPES = {
    CONTRACT: 'contract',
    PROPOSAL: 'proposal',
    INVOICE: 'invoice',
    REPORT: 'report',
    PRESENTATION: 'presentation',
    SPECIFICATION: 'specification',
    REQUIREMENT: 'requirement',
    LEGAL: 'legal',
    FINANCIAL: 'financial',
    TECHNICAL: 'technical',
    OTHER: 'other'
};

/**
 * Document Status Constants
 */
const DOCUMENT_STATUS = {
    DRAFT: 'draft',
    REVIEW: 'review',
    APPROVED: 'approved',
    PUBLISHED: 'published',
    ARCHIVED: 'archived',
    OBSOLETE: 'obsolete'
};

/**
 * Classification Level Constants
 */
const CLASSIFICATION_LEVELS = {
    PUBLIC: 'public',
    INTERNAL: 'internal',
    CONFIDENTIAL: 'confidential',
    RESTRICTED: 'restricted',
    TOP_SECRET: 'top_secret'
};

/**
 * Client Document Management Service
 * @class ClientDocumentService
 */
class ClientDocumentService {
    constructor() {
        this._dbService = null;
        this.notificationService = NotificationService;
        this.analyticsService = AnalyticsService;

        // Configuration
        this.config = {
            companyTenantId: process.env.COMPANY_TENANT_ID || 'default',
            platformUrl: process.env.PLATFORM_URL || 'https://yourplatform.com',
            storageBasePath: process.env.DOCUMENT_STORAGE_PATH || '/storage/documents',
            autoGenerateDocumentId: process.env.AUTO_GENERATE_DOCUMENT_ID !== 'false',
            maxDocumentSize: parseInt(process.env.MAX_DOCUMENT_SIZE, 10) || 104857600, // 100MB
            enableVersionControl: process.env.ENABLE_VERSION_CONTROL !== 'false',
            maxVersionsToKeep: parseInt(process.env.MAX_VERSIONS_TO_KEEP, 10) || 10,
            allowedFileTypes: (process.env.ALLOWED_DOCUMENT_TYPES || 'pdf,doc,docx,xls,xlsx,ppt,pptx,txt,csv,jpg,jpeg,png').split(','),
            maxDocumentsPerClient: parseInt(process.env.MAX_DOCUMENTS_PER_CLIENT, 10) || 1000
        };
    }

    /**
     * Get database service instance
     * @private
     * @returns {Object} Database service
     */
    _getDatabaseService() {
        if (!this._dbService) {
            this._dbService = database.getDatabaseService();
        }
        return this._dbService;
    }

    // ============= DOCUMENT CREATION & MANAGEMENT =============

    /**
     * Create a new document with enterprise-grade validation and context inheritance
     * Handles documents uploaded directly to S3 via multer-s3
     */
    async createDocument(documentData, options = {}) {
        const operationId = crypto.randomBytes(8).toString('hex');
        const startTime = Date.now();

        try {
            logger.info('Starting document creation', {
                operationId,
                clientId: documentData.clientId,
                documentName: documentData.documentInfo?.name,
                documentType: documentData.documentInfo?.type,
                userId: options.userId,
                source: options.source || 'manual',
                hasFileUpload: !!options.uploadedFile,
                s3Upload: options.uploadedFile?.location ? 'direct' : 'none'
            });

            // PHASE 1: INPUT VALIDATION
            await this._validateDocumentData(documentData);

            if (!documentData.clientId || !mongoose.Types.ObjectId.isValid(documentData.clientId)) {
                throw AppError.validation('Valid client ID is required', {
                    context: {
                        providedClientId: documentData.clientId,
                        field: 'clientId'
                    }
                });
            }

            // PHASE 2: CLIENT VERIFICATION AND CONTEXT INHERITANCE
            const dbService = this._getDatabaseService();
            const Client = dbService.getModel('Client', 'customer');

            const parentClient = await Client.findById(documentData.clientId)
                .select('tenantId organizationId companyName relationship.status')
                .lean();

            if (!parentClient) {
                throw AppError.notFound('Parent client not found', {
                    context: { clientId: documentData.clientId }
                });
            }

            if (parentClient.relationship?.status === 'inactive' ||
                parentClient.relationship?.status === 'churned') {
                throw AppError.validation(
                    'Cannot create documents for inactive or churned clients',
                    {
                        context: {
                            clientId: documentData.clientId,
                            clientStatus: parentClient.relationship.status
                        }
                    }
                );
            }

            // PHASE 3: ACCESS CONTROL VERIFICATION
            if (options.userClientId) {
                if (parentClient._id.toString() !== options.userClientId.toString()) {
                    throw AppError.forbidden(
                        'You can only create documents for your own account',
                        {
                            context: {
                                requestedClientId: documentData.clientId,
                                userClientId: options.userClientId
                            }
                        }
                    );
                }
                logger.debug('Self-service access validated', {
                    operationId,
                    userId: options.userId,
                    clientId: options.userClientId
                });
            } else if (options.tenantId && !options.skipTenantCheck) {
                if (!mongoose.Types.ObjectId.isValid(options.tenantId)) {
                    throw AppError.validation('Valid tenant ID required in authentication context', {
                        context: {
                            providedTenantId: options.tenantId,
                            clientTenantId: parentClient.tenantId
                        }
                    });
                }

                if (parentClient.tenantId.toString() !== options.tenantId.toString()) {
                    throw AppError.forbidden('Access denied to this client', {
                        context: {
                            clientTenantId: parentClient.tenantId.toString(),
                            userTenantId: options.tenantId.toString()
                        }
                    });
                }

                logger.debug('Administrative access validated', {
                    operationId,
                    userId: options.userId,
                    tenantId: options.tenantId
                });
            }

            // PHASE 4: S3 FILE UPLOAD PROCESSING
            if (options.uploadedFile) {
                logger.debug('Processing S3-uploaded file', {
                    operationId,
                    originalName: options.uploadedFile.originalname,
                    mimeType: options.uploadedFile.mimetype,
                    size: options.uploadedFile.size,
                    s3Location: options.uploadedFile.location,
                    s3Bucket: options.uploadedFile.bucket,
                    s3Key: options.uploadedFile.key
                });

                const uploadedFile = options.uploadedFile;
                const fileExtension = path.extname(uploadedFile.originalname).toLowerCase().replace('.', '');

                // Validate file type
                await this._validateFileType(fileExtension);

                // Validate file size
                await this._validateFileSize(uploadedFile.size);

                // Extract S3 information from the uploaded file object
                const bucketName = uploadedFile.bucket;
                const s3Key = uploadedFile.key;
                const storageUrl = uploadedFile.location;
                const region = S3UrlHelper.extractRegion(storageUrl) || process.env.AWS_DEFAULT_REGION || 'ap-southeast-1';

                // Verify the URL is in correct virtual-hosted-style format
                const validation = S3UrlHelper.validateUrl(storageUrl);

                if (!validation.valid) {
                    logger.error('S3 upload produced invalid URL format', {
                        operationId,
                        url: storageUrl,
                        validation: validation,
                        bucket: bucketName,
                        key: s3Key
                    });
                    throw AppError.internal('Invalid storage URL generated during S3 upload', {
                        context: {
                            url: storageUrl,
                            issues: validation.issues
                        }
                    });
                }

                if (validation.needsConversion) {
                    logger.warn('S3 URL requires conversion to virtual-hosted-style', {
                        operationId,
                        originalUrl: storageUrl,
                        format: validation.format
                    });

                    const convertedUrl = S3UrlHelper.convertToVirtualHostedStyle(storageUrl, region);
                    uploadedFile.location = convertedUrl;
                }

                logger.debug('S3 file upload validated successfully', {
                    operationId,
                    bucket: bucketName,
                    key: s3Key,
                    url: uploadedFile.location,
                    urlFormat: validation.format,
                    region: region
                });

                // Populate file details from S3 upload
                documentData.fileDetails = {
                    originalName: uploadedFile.originalname,
                    fileName: path.basename(s3Key),
                    fileExtension: fileExtension,
                    mimeType: uploadedFile.mimetype,
                    size: uploadedFile.size,
                    encoding: uploadedFile.encoding || 'binary',
                    checksum: {
                        md5: uploadedFile.etag ? uploadedFile.etag.replace(/"/g, '') : null,
                        sha256: null
                    }
                };

                // Populate storage configuration with S3 details
                documentData.storage = {
                    provider: 'aws_s3',
                    location: {
                        bucket: bucketName,
                        path: s3Key,
                        region: region
                    },
                    url: uploadedFile.location,
                    encryption: {
                        enabled: true,
                        algorithm: 'AES256'
                    }
                };

                logger.info('S3 file upload processed successfully', {
                    operationId,
                    fileName: path.basename(s3Key),
                    size: uploadedFile.size,
                    storageUrl: uploadedFile.location,
                    bucket: bucketName,
                    region: region
                });

            } else if (documentData.fileDetails || documentData.storage) {
                // Handle case where file details are provided directly without upload
                // This supports API integrations or document references

                if (documentData.fileDetails?.fileExtension) {
                    await this._validateFileType(documentData.fileDetails.fileExtension);
                }

                if (documentData.fileDetails?.size) {
                    await this._validateFileSize(documentData.fileDetails.size);
                }

                // CRITICAL FIX: Always use configured bucket from environment
                const configuredBucket = process.env.AWS_S3_BUCKET || 'insightserenity-ap';
                const configuredRegion = process.env.AWS_DEFAULT_REGION || 'ap-southeast-1';

                // If storage URL is provided, extract the key and rebuild with correct bucket
                if (documentData.storage?.url) {
                    const providedKey = S3UrlHelper.extractKey(documentData.storage.url);
                    const providedBucket = S3UrlHelper.extractBucketName(documentData.storage.url);

                    // Log if bucket mismatch detected
                    if (providedBucket && providedBucket !== configuredBucket) {
                        logger.warn('Bucket mismatch detected - using configured bucket', {
                            operationId,
                            providedBucket: providedBucket,
                            configuredBucket: configuredBucket,
                            originalUrl: documentData.storage.url
                        });
                    }

                    // Generate correct URL using configured bucket
                    const correctedUrl = S3UrlHelper.generateUrl({
                        bucket: configuredBucket,
                        key: providedKey,
                        region: configuredRegion
                    });

                    documentData.storage.url = correctedUrl;

                    // Populate storage location with correct values
                    documentData.storage.location = {
                        bucket: configuredBucket,
                        region: configuredRegion,
                        path: providedKey
                    };

                    // Set provider if not already set
                    if (!documentData.storage.provider) {
                        documentData.storage.provider = 'aws_s3';
                    }

                    logger.info('Storage URL corrected to use configured bucket', {
                        operationId,
                        correctedUrl: correctedUrl,
                        bucket: configuredBucket,
                        region: configuredRegion,
                        path: providedKey
                    });
                } else if (documentData.storage?.location?.path) {
                    // If only path is provided, generate full URL
                    const generatedUrl = S3UrlHelper.generateUrl({
                        bucket: configuredBucket,
                        key: documentData.storage.location.path,
                        region: configuredRegion
                    });

                    documentData.storage.url = generatedUrl;
                    documentData.storage.location.bucket = configuredBucket;
                    documentData.storage.location.region = configuredRegion;

                    if (!documentData.storage.provider) {
                        documentData.storage.provider = 'aws_s3';
                    }

                    logger.info('Storage URL generated from path', {
                        operationId,
                        generatedUrl: generatedUrl,
                        bucket: configuredBucket,
                        region: configuredRegion,
                        path: documentData.storage.location.path
                    });
                }
            }

            // PHASE 5: BUSINESS RULE VALIDATION
            await this._checkDocumentLimit(documentData.clientId);

            // PHASE 6: DATA ENRICHMENT AND PREPARATION
            if (!documentData.documentId && this.config.autoGenerateDocumentId) {
                documentData.documentId = await this._generateDocumentId();
            }

            documentData.tenantId = parentClient.tenantId;
            documentData.organizationId = parentClient.organizationId;

            // Initialize lifecycle
            if (!documentData.lifecycle) {
                documentData.lifecycle = {};
            }
            documentData.lifecycle.status = documentData.lifecycle.status || DOCUMENT_STATUS.DRAFT;

            // Initialize versioning if enabled
            if (this.config.enableVersionControl) {
                documentData.versioning = {
                    version: {
                        major: 1,
                        minor: 0,
                        patch: 0
                    },
                    versionString: '1.0.0',
                    isLatest: true,
                    isDraft: documentData.lifecycle.status === DOCUMENT_STATUS.DRAFT,
                    versionHistory: [],
                    changeLog: []
                };
            }

            // Initialize access control
            if (!documentData.accessControl) {
                documentData.accessControl = {
                    owner: options.userId,
                    permissions: {
                        public: false,
                        inherited: true,
                        groups: [],
                        users: [],
                        roles: []
                    },
                    sharing: {
                        isShared: false,
                        sharedWith: [],
                        publicLink: {
                            enabled: false
                        }
                    },
                    restrictions: {
                        downloadDisabled: false,
                        printDisabled: false,
                        copyDisabled: false,
                        viewCount: 0
                    }
                };
            }

            // Initialize analytics
            if (!documentData.analytics) {
                documentData.analytics = {
                    views: {
                        total: 0,
                        unique: 0,
                        viewHistory: []
                    },
                    downloads: {
                        total: 0,
                        downloadHistory: []
                    },
                    shares: {
                        total: 0,
                        internal: 0,
                        external: 0
                    },
                    prints: {
                        total: 0
                    }
                };
            }

            // Set metadata
            documentData.metadata = {
                source: options.source || 'upload',
                uploadedBy: options.userId,
                uploadedAt: new Date(),
                flags: {
                    isFavorite: false,
                    isPinned: false,
                    isTemplate: false,
                    requiresAction: false
                }
            };

            documentData.isDeleted = false;

            // PHASE 7: DATABASE PERSISTENCE
            const ClientDocument = dbService.getModel('ClientDocument', 'customer');
            const newDocument = new ClientDocument(documentData);
            await newDocument.save();

            const duration = Date.now() - startTime;

            logger.info('Document created successfully', {
                operationId,
                documentId: newDocument.documentId,
                clientId: newDocument.clientId,
                tenantId: newDocument.tenantId.toString(),
                organizationId: newDocument.organizationId?.toString(),
                documentName: newDocument.documentInfo?.name,
                documentType: newDocument.documentInfo?.type,
                storageProvider: newDocument.storage?.provider,
                storageUrl: newDocument.storage?.url,
                storageBucket: newDocument.storage?.location?.bucket,
                storageRegion: newDocument.storage?.location?.region,
                storagePath: newDocument.storage?.location?.path,
                fileSize: newDocument.fileDetails?.size,
                userId: options.userId,
                duration: `${duration}ms`
            });

            // PHASE 8: POST-CREATION ACTIVITIES
            setImmediate(async () => {
                try {
                    await this._handlePostDocumentCreation(newDocument, options);
                } catch (postError) {
                    logger.error('Post-creation activities failed (non-critical)', {
                        operationId,
                        documentId: newDocument.documentId,
                        error: postError.message,
                        stack: postError.stack
                    });
                }
            });

            return this._sanitizeDocumentOutput(newDocument);

        } catch (error) {
            const duration = Date.now() - startTime;

            logger.error('Document creation failed', {
                operationId,
                error: error.message,
                errorCode: error.code,
                stack: error.stack,
                clientId: documentData?.clientId,
                userId: options?.userId,
                s3Location: options?.uploadedFile?.location,
                duration: `${duration}ms`,
                context: error.context || {}
            });

            if (error instanceof AppError) {
                throw error;
            }

            if (error.name === 'ValidationError') {
                throw AppError.validation('Document validation failed', {
                    errors: Object.keys(error.errors).map(key => ({
                        field: key,
                        message: error.errors[key].message,
                        value: error.errors[key].value
                    }))
                });
            }

            throw AppError.internal('Document creation failed', {
                originalError: error.message,
                operationId
            });
        }
    }

    /**
     * Get documents for authenticated client with filtering and sorting
     * This method is design for self-service access where clients retireve their own documents
     * @param {Object} options - Query options
     * @param {string} options.userClientId - Client ID from authenticated user (required for self-service)
     * @param {string} options.tenantId - Tenant ID from authenticated user (for admin access)
     * @param {string} options.status - Filter by document status
     * @param {string} options.search - Search term for document name or description
     * @param {string} options.sortBy - Field to sort by (default: createdAt)
     * @param {string} options.sortOrder - Sort order: 'asc' or 'desc' (default: desc)
     * @param {number} options.limit - Maximum number of documents to return (default: 50)
     * @param {number} options.skip - Number of documents to skip for pagination (default: 0)
     * @param {boolean} options.includeDeleted - Include soft-deteleted documents
     * @returns {Promise<Object>} Object containing documents array and metadata
     */
    async getDocuments(options = {}) {
        const startTime = Date.now();
        try {
            logger.info('Fetching documents with filters', {
                userClientId: options.userClientId,
                tenantId: options.tenantId,
                filters: {
                    status: options.status,
                    role: options.role,
                    search: options.search
                }
            });

            // PHASE 1: ACCESS CONTROL
            let clientId;
            if (options.userClientId) {
                // Self-service access - client accessing their own documents
                if (!mongoose.Types.ObjectId.isValid(options.userClientId)) {
                    throw AppError.validation('Invalid client ID', {
                        context: { userClientId: options.userClientId }
                    });
                }
                clientId = options.userClientId;
                logger.debug('Self-service access - retrieving own contacts', {
                    clientId: clientId
                });
            }

            // PHASE 2: BUILD QUERY
            const dbService = this._getDatabaseService();
            const ClientDocument = dbService.getModel('ClientDocument', 'customer');

            const query = {
                clientId: clientId,
                isDeleted: options.includeDeleted === true ? { $in: [true, false] } : { $ne: true }
            };

            // Apply status filter
            if (options.status) {
                if (!Object.values(DOCUMENT_STATUS).includes(options.status)) {
                    throw AppError.validation('Invalid document status filter', {
                        context: {
                            provided: options.status,
                            validValues: Object.values(DOCUMENT_STATUS)
                        }
                    });
                }
                query['lifecycle.status'] = options.status;
            } else {
                // Default to active documents only
                query['lifecycle.status'] = { $ne: DOCUMENT_STATUS.ARCHIVED };
            }

            // Apply search filter
            if (options.search && options.search.trim()) {
                const searchTerm = options.search.trim();
                query.$or = [
                    { 'documentInfo.name': { $regex: searchTerm, $options: 'i' } },
                    { 'documentInfo.description': { $regex: searchTerm, $options: 'i' } },
                ];
            }

            // PHASE 3: BUILD SORT OPTIONS
            const sortBy = options.sortBy || 'documentInfo.name';
            const sortOrder = options.sortOrder === 'asc' ? -1 : 1;
            const sort = { [sortBy]: sortOrder };

            // Add secondary sort by name for consistent ordering
            if (sortBy !== 'documentInfo.name') sort['documentInfo.name'] = 1;

            // PHASE 4: PAGINATION
            const limit = options.limit ? parseInt(options.limit, 10) : 50;
            const skip = options.skip ? parseInt(options.skip, 10) : 0;

            if (limit > 100) throw AppError.validation('Limit exceeds maximum of 100', { context: { requestdLimit: limit, maxLimit: 100 } });

            // PHASE 5: EXECUTE QUERY
            const [documents, totalCount] = await Promise.all([
                ClientDocument.find(query)
                    .select('-__v -accessControl.restrictions -analytics.views.viewHistory -analytics.downloads.downloadHistory')
                    .sort(sort)
                    .skip(skip)
                    .limit(limit)
                    .lean(),
                ClientDocument.countDocuments(query)
            ]);

            // PHASE 6: SANITIZE OUTPUT
            const sanitizedDocuments = documents.map(document => this._sanitizeDocumentOutput(document));
            const duration = Date.now() - startTime;
            logger.info('Documents fetched successfully', {
                clientId: clientId,
                count: documents.length,
                totalCount: totalCount,
                duration: `${duration}ms`,
                filters: {
                    status: options.status,
                    role: options.role,
                    hasSearch: !!options.search
                }
            });

            return {
                documents: sanitizedDocuments,
                metadata: {
                    total: totalCount,
                    count: documents.length,
                    limit: limit,
                    skip: skip,
                    hasMore: skip + documents.length < totalCount,
                    filters: {
                        status: options.status || DOCUMENT_STATUS,
                        search: options.search
                    }
                }
            }
        } catch (error) {
            const duration = Date.now() - startTime;
            logger.error('Failed to fetch documents', {
                error: error.message,
                duration: `${duration}ms`,
                userClientId: options.userClientId,
            })
        }
    }

    /**
     * Get document by ID with enterprise-grade access control
     */
    async getDocumentById(documentId, options = {}) {
        try {
            logger.info('Fetching document by ID', { documentId });

            if (!mongoose.Types.ObjectId.isValid(documentId)) {
                throw AppError.validation('Invalid document ID format', {
                    context: { documentId }
                });
            }

            const dbService = this._getDatabaseService();
            const ClientDocument = dbService.getModel('ClientDocument', 'customer');
            const Client = dbService.getModel('Client', 'customer');

            // Fetch document without population
            const document = await ClientDocument.findById(documentId).lean();

            if (!document) {
                throw AppError.notFound('Document not found', {
                    context: { documentId }
                });
            }

            if (document.isDeleted && !options.includeDeleted) {
                throw AppError.notFound('Document not found', {
                    context: { documentId }
                });
            }

            // Manually fetch client data if needed
            if (options.populate) {
                const client = await Client.findById(document.clientId)
                    .select('companyName clientCode tenantId organizationId')
                    .lean();

                if (client) {
                    document.clientId = client;
                }
            } else {
                const client = await Client.findById(document.clientId)
                    .select('tenantId organizationId')
                    .lean();

                if (client) {
                    document.clientId = client;
                }
            }

            // ACCESS CONTROL: Self-service check
            if (options.userClientId) {
                const clientIdString = document.clientId._id ?
                    document.clientId._id.toString() :
                    document.clientId.toString();

                if (clientIdString !== options.userClientId.toString()) {
                    throw AppError.forbidden('You can only access documents from your own account', {
                        context: {
                            documentClientId: clientIdString,
                            userClientId: options.userClientId
                        }
                    });
                }
            }
            // ACCESS CONTROL: Administrative tenant check
            else if (options.tenantId && !options.skipTenantCheck) {
                if (!mongoose.Types.ObjectId.isValid(options.tenantId)) {
                    throw AppError.validation('Valid tenant ID required in authentication context');
                }

                const documentTenantId = document.clientId.tenantId ?
                    document.clientId.tenantId.toString() :
                    document.tenantId.toString();

                if (documentTenantId !== options.tenantId.toString()) {
                    throw AppError.forbidden('Access denied to this document', {
                        context: {
                            documentTenantId: documentTenantId,
                            userTenantId: options.tenantId.toString()
                        }
                    });
                }
            }

            logger.info('Document fetched successfully', {
                documentId: document._id,
                clientId: document.clientId._id || document.clientId
            });

            // Track view
            if (options.trackView && options.userId) {
                setImmediate(async () => {
                    try {
                        await this._recordDocumentView(document._id, options.userId);
                    } catch (trackError) {
                        logger.error('Failed to track document view', {
                            error: trackError.message,
                            documentId: document._id
                        });
                    }
                });
            }

            return this._sanitizeDocumentOutput(document);

        } catch (error) {
            logger.error('Failed to fetch document', {
                error: error.message,
                documentId
            });
            throw error;
        }
    }

    /**
     * Get all documents for a client with access control
     */
    async getDocumentsByClient(clientId, options = {}) {
        try {
            logger.info('Fetching documents by client', { clientId });

            // Validate client ID format
            if (!mongoose.Types.ObjectId.isValid(clientId)) {
                throw AppError.validation('Invalid client ID format', {
                    context: { clientId }
                });
            }

            const dbService = this._getDatabaseService();
            const Client = dbService.getModel('Client', 'customer');
            const ClientDocument = dbService.getModel('ClientDocument', 'customer');

            // Verify client exists and get tenant information
            const client = await Client.findById(clientId)
                .select('tenantId organizationId companyName')
                .lean();

            if (!client) {
                throw AppError.notFound('Client not found', {
                    context: { clientId }
                });
            }

            // ACCESS CONTROL: Self-service check
            if (options.userClientId) {
                if (client._id.toString() !== options.userClientId.toString()) {
                    throw AppError.forbidden('You can only access documents from your own account', {
                        context: {
                            requestedClientId: clientId,
                            userClientId: options.userClientId
                        }
                    });
                }
            }
            // ACCESS CONTROL: Administrative tenant check
            else if (options.tenantId && !options.skipTenantCheck) {
                if (!mongoose.Types.ObjectId.isValid(options.tenantId)) {
                    throw AppError.validation('Valid tenant ID required in authentication context');
                }

                if (client.tenantId.toString() !== options.tenantId.toString()) {
                    throw AppError.forbidden('Access denied to this client', {
                        context: {
                            clientTenantId: client.tenantId.toString(),
                            userTenantId: options.tenantId.toString()
                        }
                    });
                }
            }

            // Build query
            const query = {
                clientId: clientId,
                isDeleted: { $ne: true }
            };

            // Filter by document type if provided
            if (options.type) {
                query['documentInfo.type'] = options.type;
            }

            // Filter by status if provided
            if (options.status) {
                query['lifecycle.status'] = options.status;
            }

            // Filter by project if provided
            if (options.projectId) {
                query.projectId = options.projectId;
            }

            // Filter by classification level if provided
            if (options.classificationLevel) {
                query['documentInfo.classification.level'] = options.classificationLevel;
            }

            // Build and execute query
            const sortField = options.sortBy || 'createdAt';
            const sortOrder = options.sortOrder === 'asc' ? 1 : -1;

            const documents = await ClientDocument.find(query)
                .sort({ [sortField]: sortOrder })
                .lean();

            logger.info('Documents fetched successfully', {
                clientId,
                count: documents.length
            });

            return documents.map(d => this._sanitizeDocumentOutput(d));

        } catch (error) {
            logger.error('Failed to fetch documents by client', {
                error: error.message,
                clientId
            });
            throw error;
        }
    }

    /**
     * Get all documents for authenticated client with filtering and sorting
     * This method is designed for self-service access where clients retrieve their own documents
     * @param {Object} options - Query options
     * @param {string} options.userClientId - Client ID from authenticated user (required for self-service)
     * @param {string} options.tenantId - Tenant ID for admin access
     * @param {string} options.type - Filter by document type (contract, proposal, invoice, report, etc.)
     * @param {string} options.status - Filter by lifecycle status (draft, review, approved, published, archived)
     * @param {string} options.classification - Filter by classification level (public, internal, confidential, restricted)
     * @param {string} options.search - Search term for name, description, or keywords
     * @param {string} options.sortBy - Field to sort by (default: 'createdAt')
     * @param {string} options.sortOrder - Sort order: 'asc' or 'desc' (default: 'desc')
     * @param {number} options.limit - Maximum number of documents to return (max 100, default: 50)
     * @param {number} options.skip - Number of documents to skip for pagination (default: 0)
     * @param {boolean} options.includeDeleted - Include soft-deleted documents (default: false)
     * @param {boolean} options.onlyLatest - Only return latest versions (default: true)
     * @returns {Promise<Object>} Object containing documents array and metadata
     */
    async getDocuments(options = {}) {
        const operationId = crypto.randomBytes(8).toString('hex');
        const startTime = Date.now();

        try {
            logger.info('Starting get all documents operation', {
                operationId,
                userClientId: options.userClientId,
                tenantId: options.tenantId,
                filters: {
                    type: options.type,
                    status: options.status,
                    classification: options.classification,
                    search: options.search
                }
            });

            // PHASE 1: ACCESS CONTROL
            let clientId;

            if (options.userClientId) {
                // Self-service access - client accessing their own documents
                if (!mongoose.Types.ObjectId.isValid(options.userClientId)) {
                    throw AppError.validation('Invalid client ID', {
                        context: { userClientId: options.userClientId }
                    });
                }
                clientId = options.userClientId;

                logger.debug('Self-service access - retrieving own documents', {
                    operationId,
                    clientId: clientId
                });
            } else if (options.tenantId) {
                // Administrative access - would need clientId specified
                throw AppError.validation('Client ID required for administrative access', {
                    context: {
                        message: 'Use getDocumentsByClient method for admin operations with specific clientId'
                    }
                });
            } else {
                throw AppError.unauthorized('Authentication required', {
                    context: { message: 'User must be authenticated to retrieve documents' }
                });
            }

            // PHASE 2: BUILD QUERY
            const dbService = this._getDatabaseService();
            const ClientDocument = dbService.getModel('ClientDocument', 'customer');

            const query = {
                clientId: clientId,
                isDeleted: options.includeDeleted === true ? { $in: [true, false] } : { $ne: true }
            };

            // Apply version filter
            if (options.onlyLatest !== false) {
                query['versioning.isLatest'] = true;
            }

            // Apply type filter
            if (options.type) {
                const validTypes = [
                    'contract', 'proposal', 'invoice', 'report', 'presentation',
                    'specification', 'requirement', 'design', 'legal', 'financial',
                    'technical', 'meeting_notes', 'correspondence', 'certificate',
                    'policy', 'procedure', 'template', 'form', 'image', 'video', 'other'
                ];

                if (!validTypes.includes(options.type)) {
                    throw AppError.validation('Invalid document type filter', {
                        context: {
                            provided: options.type,
                            validValues: validTypes
                        }
                    });
                }
                query['documentInfo.type'] = options.type;
            }

            // Apply status filter
            if (options.status) {
                const validStatuses = ['draft', 'review', 'approved', 'published', 'archived', 'obsolete', 'deleted'];

                if (!validStatuses.includes(options.status)) {
                    throw AppError.validation('Invalid status filter', {
                        context: {
                            provided: options.status,
                            validValues: validStatuses
                        }
                    });
                }
                query['lifecycle.status'] = options.status;
            } else {
                // Default to active documents only
                query['lifecycle.status'] = { $nin: ['deleted', 'obsolete'] };
            }

            // Apply classification filter
            if (options.classification) {
                const validClassifications = ['public', 'internal', 'confidential', 'restricted', 'top_secret'];

                if (!validClassifications.includes(options.classification)) {
                    throw AppError.validation('Invalid classification filter', {
                        context: {
                            provided: options.classification,
                            validValues: validClassifications
                        }
                    });
                }
                query['documentInfo.classification.level'] = options.classification;
            }

            // Apply search filter
            if (options.search && options.search.trim()) {
                const searchTerm = options.search.trim();
                query.$or = [
                    { 'documentInfo.name': { $regex: searchTerm, $options: 'i' } },
                    { 'documentInfo.displayName': { $regex: searchTerm, $options: 'i' } },
                    { 'documentInfo.description': { $regex: searchTerm, $options: 'i' } },
                    { 'documentInfo.keywords': { $regex: searchTerm, $options: 'i' } },
                    { 'fileDetails.originalName': { $regex: searchTerm, $options: 'i' } }
                ];
            }

            // PHASE 3: BUILD SORT OPTIONS
            const sortBy = options.sortBy || 'createdAt';
            const sortOrder = options.sortOrder === 'asc' ? 1 : -1;
            const sort = { [sortBy]: sortOrder };

            // Add secondary sort by name for consistent ordering
            if (sortBy !== 'documentInfo.name') {
                sort['documentInfo.name'] = 1;
            }

            // PHASE 4: PAGINATION
            const limit = options.limit ? parseInt(options.limit, 10) : 50;
            const skip = options.skip ? parseInt(options.skip, 10) : 0;

            if (limit > 100) {
                throw AppError.validation('Limit cannot exceed 100 documents per request', {
                    context: { requestedLimit: limit, maxLimit: 100 }
                });
            }

            // PHASE 5: EXECUTE QUERY
            const [documents, totalCount] = await Promise.all([
                ClientDocument.find(query)
                    .select('-__v -contentExtraction.searchableContent -signatures.signatories.verificationCode')
                    .sort(sort)
                    .skip(skip)
                    .limit(limit)
                    .lean(),
                ClientDocument.countDocuments(query)
            ]);

            // PHASE 6: SANITIZE OUTPUT
            const sanitizedDocuments = documents.map(doc => this._sanitizeDocumentOutput(doc));

            const duration = Date.now() - startTime;

            logger.info('Get all documents completed successfully', {
                operationId,
                clientId: clientId,
                count: documents.length,
                totalCount: totalCount,
                duration: `${duration}ms`,
                filters: {
                    type: options.type,
                    status: options.status,
                    classification: options.classification,
                    hasSearch: !!options.search
                }
            });

            return {
                documents: sanitizedDocuments,
                metadata: {
                    total: totalCount,
                    count: documents.length,
                    limit: limit,
                    skip: skip,
                    hasMore: skip + documents.length < totalCount,
                    filters: {
                        type: options.type,
                        status: options.status || 'active',
                        classification: options.classification,
                        search: options.search,
                        onlyLatest: options.onlyLatest !== false
                    }
                }
            };

        } catch (error) {
            const duration = Date.now() - startTime;

            logger.error('Get all documents failed', {
                operationId,
                error: error.message,
                duration: `${duration}ms`,
                userClientId: options.userClientId
            });

            throw error;
        }
    }

    async updateDocument(documentId, updateData, options = {}) {
        try {
            logger.info('Updating document', {
                documentId,
                updateFields: Object.keys(updateData),
                userId: options.userId
            });

            if (!mongoose.Types.ObjectId.isValid(documentId)) {
                throw AppError.validation('Invalid document ID format', {
                    context: { documentId }
                });
            }

            await this._validateDocumentUpdateData(updateData);

            // Get existing document with access control
            const existingDocument = await this.getDocumentById(documentId, {
                tenantId: options.tenantId,
                userClientId: options.userClientId,
                skipTenantCheck: options.skipTenantCheck
            });

            const dbService = this._getDatabaseService();
            const ClientDocument = dbService.getModel('ClientDocument', 'customer');

            // Flatten nested objects into dot notation
            const flattenUpdate = (obj, prefix = '') => {
                const flattened = {};

                for (const [key, value] of Object.entries(obj)) {
                    const newKey = prefix ? `${prefix}.${key}` : key;

                    if (value !== null && typeof value === 'object' && !Array.isArray(value) && !(value instanceof Date)) {
                        Object.assign(flattened, flattenUpdate(value, newKey));
                    } else {
                        flattened[newKey] = value;
                    }
                }

                return flattened;
            };

            const flattenedUpdate = flattenUpdate(updateData);

            // Handle version increment if creating new version
            if (options.createNewVersion && this.config.enableVersionControl) {
                const currentVersion = existingDocument.versioning?.version || { major: 1, minor: 0, patch: 0 };
                flattenedUpdate['versioning.version.minor'] = currentVersion.minor + 1;
                flattenedUpdate['versioning.version.patch'] = 0;
                flattenedUpdate['versioning.versionString'] = `${currentVersion.major}.${currentVersion.minor + 1}.0`;
            }

            // Perform update with flattened fields
            const updatedDocument = await ClientDocument.findByIdAndUpdate(
                documentId,
                { $set: flattenedUpdate },
                { new: true, runValidators: true }
            ).lean();

            if (!updatedDocument) {
                throw AppError.notFound('Document not found for update');
            }

            logger.info('Document updated successfully', {
                documentId,
                userId: options.userId
            });

            // Track update event
            setImmediate(async () => {
                try {
                    await this._trackDocumentEvent(updatedDocument, 'document_updated', {
                        updatedFields: Object.keys(updateData),
                        userId: options.userId,
                        newVersion: options.createNewVersion
                    });
                } catch (trackError) {
                    logger.error('Failed to track update event', {
                        error: trackError.message,
                        documentId
                    });
                }
            });

            return this._sanitizeDocumentOutput(updatedDocument);

        } catch (error) {
            logger.error('Document update failed', {
                error: error.message,
                documentId
            });
            throw error;
        }
    }

    /**
     * Delete/archive document with access control
     */
    async deleteDocument(documentId, options = {}) {
        try {
            logger.info('Deleting document', {
                documentId,
                softDelete: options.softDelete,
                userId: options.userId
            });

            // Validate document ID format
            if (!mongoose.Types.ObjectId.isValid(documentId)) {
                throw AppError.validation('Invalid document ID format', {
                    context: { documentId }
                });
            }

            // Get existing document with access control
            const existingDocument = await this.getDocumentById(documentId, {
                tenantId: options.tenantId,
                userClientId: options.userClientId,
                skipTenantCheck: options.skipTenantCheck
            });

            const dbService = this._getDatabaseService();
            const ClientDocument = dbService.getModel('ClientDocument', 'customer');

            let result;

            if (options.softDelete !== false) {
                // Soft delete - mark as deleted
                result = await ClientDocument.findByIdAndUpdate(
                    documentId,
                    {
                        $set: {
                            isDeleted: true,
                            'lifecycle.status': DOCUMENT_STATUS.ARCHIVED,
                            deletedAt: new Date(),
                            deletedBy: options.userId
                        }
                    },
                    { new: true }
                ).lean();
            } else {
                // Hard delete - only if authorized
                if (!options.forceDelete) {
                    throw AppError.forbidden('Hard delete requires force flag');
                }
                result = await ClientDocument.findByIdAndDelete(documentId).lean();
            }

            logger.info('Document deleted successfully', {
                documentId,
                softDelete: options.softDelete !== false,
                userId: options.userId
            });

            // Track deletion event
            setImmediate(async () => {
                try {
                    await this._trackDocumentEvent(existingDocument, 'document_deleted', {
                        softDelete: options.softDelete !== false,
                        userId: options.userId
                    });
                } catch (trackError) {
                    logger.error('Failed to track deletion event', {
                        error: trackError.message,
                        documentId
                    });
                }
            });

            return {
                success: true,
                documentId,
                deletionType: options.softDelete !== false ? 'soft' : 'hard'
            };

        } catch (error) {
            logger.error('Document deletion failed', {
                error: error.message,
                documentId
            });
            throw error;
        }
    }

    /**
     * Download document with access control
     */
    async downloadDocument(documentId, options = {}) {
        try {
            logger.info('Downloading document', {
                documentId,
                userId: options.userId
            });

            // Get document with access control
            const document = await this.getDocumentById(documentId, {
                tenantId: options.tenantId,
                userClientId: options.userClientId,
                skipTenantCheck: options.skipTenantCheck
            });

            // Check download restrictions
            if (document.accessControl?.restrictions?.downloadDisabled) {
                throw AppError.forbidden('Download is disabled for this document');
            }

            // Generate pre-signed URL for secure download
            let downloadUrl = null;
            const bucket = document.storage?.location?.bucket;
            const key = document.storage?.location?.path;

            if (bucket && key) {
                try {
                    const command = new GetObjectCommand({
                        Bucket: bucket,
                        Key: key,
                        ResponseContentDisposition: `attachment; filename="${encodeURIComponent(document.fileDetails?.originalName || document.documentInfo?.name || 'document')}"`
                    });

                    // URL expires in 15 minutes (900 seconds)
                    downloadUrl = await getSignedUrl(s3Client, command, { expiresIn: 900 });

                    logger.info('Pre-signed download URL generated', {
                        documentId,
                        bucket,
                        key,
                        expiresIn: 900
                    });
                } catch (s3Error) {
                    logger.error('Failed to generate pre-signed URL', {
                        error: s3Error.message,
                        documentId,
                        bucket,
                        key
                    });
                    throw AppError.internal('Failed to generate download URL', {
                        context: { documentId }
                    });
                }
            } else {
                logger.error('Missing storage location information', {
                    documentId,
                    hasBucket: !!bucket,
                    hasKey: !!key
                });
                throw AppError.internal('Document storage information is incomplete');
            }

            // Track download
            setImmediate(async () => {
                try {
                    await this._recordDocumentDownload(document._id, options.userId);
                } catch (trackError) {
                    logger.error('Failed to track document download', {
                        error: trackError.message,
                        documentId
                    });
                }
            });

            return {
                document: this._sanitizeDocumentOutput(document),
                downloadUrl: downloadUrl,
                fileName: document.fileDetails?.originalName || document.documentInfo?.name
            };

        } catch (error) {
            logger.error('Document download failed', {
                error: error.message,
                documentId
            });
            throw error;
        }
    }

    // ============= VALIDATION METHODS =============

    /**
     * Validate document data with enhanced error reporting
     * @private
     */
    async _validateDocumentData(documentData) {
        const errors = [];

        logger.debug('Starting document data validation', {
            hasClientId: !!documentData.clientId,
            hasDocumentInfo: !!documentData.documentInfo
        });

        // Required fields
        if (!documentData.clientId) {
            errors.push({ field: 'clientId', message: 'Client ID is required' });
        }

        if (!documentData.documentInfo?.name) {
            errors.push({ field: 'documentInfo.name', message: 'Document name is required' });
        }

        if (documentData.documentInfo?.name && documentData.documentInfo.name.length > 500) {
            errors.push({ field: 'documentInfo.name', message: 'Document name exceeds maximum length of 500 characters' });
        }

        if (!documentData.documentInfo?.type) {
            errors.push({ field: 'documentInfo.type', message: 'Document type is required' });
        }

        // Validate document type
        if (documentData.documentInfo?.type) {
            const validTypes = Object.values(DOCUMENT_TYPES);
            if (!validTypes.includes(documentData.documentInfo.type)) {
                errors.push({
                    field: 'documentInfo.type',
                    message: `Invalid document type. Must be one of: ${validTypes.join(', ')}`
                });
            }
        }

        if (errors.length > 0) {
            logger.error('Document validation failed with errors', {
                errors: errors,
                documentData: {
                    clientId: documentData.clientId,
                    documentName: documentData.documentInfo?.name,
                    documentType: documentData.documentInfo?.type
                }
            });

            throw AppError.validation('Document validation failed', { errors });
        }

        logger.debug('Document validation passed successfully');
    }

    /**
     * Validate document update data
     * @private
     */
    async _validateDocumentUpdateData(updateData) {
        const errors = [];

        // Cannot update immutable fields
        const immutableFields = ['documentId', 'clientId', 'tenantId', 'organizationId', 'metadata.uploadedAt', 'metadata.uploadedBy'];
        for (const field of immutableFields) {
            if (updateData[field] !== undefined) {
                errors.push({ field, message: `${field} cannot be updated` });
            }
        }

        // Validate document name length if provided
        if (updateData.documentInfo?.name && updateData.documentInfo.name.length > 500) {
            errors.push({ field: 'documentInfo.name', message: 'Document name exceeds maximum length of 500 characters' });
        }

        if (errors.length > 0) {
            throw AppError.validation('Document update validation failed', { errors });
        }
    }

    /**
     * Validate file type
     * @private
     */
    async _validateFileType(fileExtension) {
        const ext = fileExtension.toLowerCase().replace('.', '');
        if (!this.config.allowedFileTypes.includes(ext)) {
            throw AppError.validation(`File type .${ext} is not allowed`, {
                context: {
                    allowedTypes: this.config.allowedFileTypes
                }
            });
        }
    }

    /**
     * Validate file size
     * @private
     */
    async _validateFileSize(size) {
        if (size > this.config.maxDocumentSize) {
            const maxSizeMB = (this.config.maxDocumentSize / (1024 * 1024)).toFixed(2);
            const fileSizeMB = (size / (1024 * 1024)).toFixed(2);
            throw AppError.validation(`File size (${fileSizeMB}MB) exceeds maximum allowed (${maxSizeMB}MB)`, {
                context: {
                    fileSize: size,
                    maxSize: this.config.maxDocumentSize,
                    fileSizeMB,
                    maxSizeMB
                }
            });
        }
    }

    /**
     * Check document limit for client
     * @private
     */
    async _checkDocumentLimit(clientId) {
        const dbService = this._getDatabaseService();
        const ClientDocument = dbService.getModel('ClientDocument', 'customer');

        const count = await ClientDocument.countDocuments({
            clientId: clientId,
            isDeleted: { $ne: true }
        });

        if (count >= this.config.maxDocumentsPerClient) {
            throw AppError.validation('Document limit reached for this client', {
                context: {
                    currentCount: count,
                    maxAllowed: this.config.maxDocumentsPerClient
                }
            });
        }
    }

    // ============= HELPER METHODS =============

    /**
     * Generate unique document ID
     * @private
     */
    async _generateDocumentId() {
        const prefix = 'DOC';
        const timestamp = Date.now().toString(36).toUpperCase();
        const random = crypto.randomBytes(4).toString('hex').toUpperCase();

        const id = `${prefix}-${timestamp}${random}`;  // Creates: DOC-XXXXXXXXXXXX (no middle dash)

        // Verify uniqueness
        const dbService = this._getDatabaseService();
        const ClientDocument = dbService.getModel('ClientDocument', 'customer');
        const existing = await ClientDocument.findOne({ documentId: id });

        if (existing) {
            return this._generateDocumentId();
        }

        return id;
    }

    /**
     * Record document view
     * @private
     */
    async _recordDocumentView(documentId, userId) {
        try {
            const dbService = this._getDatabaseService();
            const ClientDocument = dbService.getModel('ClientDocument', 'customer');

            await ClientDocument.findByIdAndUpdate(
                documentId,
                {
                    $inc: {
                        'analytics.views.total': 1
                    },
                    $set: {
                        'analytics.views.lastViewed': new Date()
                    },
                    $push: {
                        'analytics.views.viewHistory': {
                            $each: [{
                                viewedBy: userId,
                                viewedAt: new Date()
                            }],
                            $slice: -100 // Keep only last 100 views
                        }
                    }
                }
            );

            logger.debug('Document view recorded', { documentId, userId });
        } catch (error) {
            logger.error('Failed to record document view', {
                error: error.message,
                documentId,
                userId
            });
        }
    }

    /**
     * Record document download
     * @private
     */
    async _recordDocumentDownload(documentId, userId) {
        try {
            const dbService = this._getDatabaseService();
            const ClientDocument = dbService.getModel('ClientDocument', 'customer');

            await ClientDocument.findByIdAndUpdate(
                documentId,
                {
                    $inc: {
                        'analytics.downloads.total': 1
                    },
                    $set: {
                        'analytics.downloads.lastDownloaded': new Date()
                    },
                    $push: {
                        'analytics.downloads.downloadHistory': {
                            $each: [{
                                downloadedBy: userId,
                                downloadedAt: new Date()
                            }],
                            $slice: -100 // Keep only last 100 downloads
                        }
                    }
                }
            );

            logger.debug('Document download recorded', { documentId, userId });
        } catch (error) {
            logger.error('Failed to record document download', {
                error: error.message,
                documentId,
                userId
            });
        }
    }

    /**
     * Handle post-document creation activities
     * @private
     */
    async _handlePostDocumentCreation(document, options) {
        try {
            // Track creation event
            await this._trackDocumentEvent(document, 'document_created', {
                userId: options.userId,
                source: options.source || 'upload'
            });

        } catch (error) {
            logger.error('Post-document creation activities failed (non-blocking)', {
                error: error.message,
                documentId: document.documentId
            });
        }
    }

    /**
     * Track document event
     * @private
     */
    async _trackDocumentEvent(document, eventType, data) {
        try {
            if (typeof this.analyticsService.trackEvent === 'function') {
                await this.analyticsService.trackEvent({
                    type: eventType,
                    documentId: document._id || document.id,
                    clientId: document.clientId,
                    data: data
                });
            }
        } catch (error) {
            logger.error('Failed to track document event', {
                error: error.message,
                eventType,
                documentId: document._id || document.id
            });
        }
    }

    /**
     * Sanitize document output
     * @private
     */
    _sanitizeDocumentOutput(document) {
        if (!document) return null;

        const documentObject = document.toObject ? document.toObject() : document;

        // Remove sensitive and internal fields
        delete documentObject.__v;
        delete documentObject.searchTokens;
        delete documentObject.storage?.signedUrl;
        delete documentObject.contentExtraction?.searchableContent;
        delete documentObject.contentExtraction?.ocr?.text;
        delete documentObject.contentExtraction?.textContent?.content;
        delete documentObject.signatures?.signatories?.verificationCode;
        delete documentObject.accessControl?.sharing?.publicLink?.password;

        return documentObject;
    }
}

module.exports = new ClientDocumentService();