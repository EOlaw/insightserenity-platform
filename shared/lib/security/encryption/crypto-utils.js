const crypto = require('crypto');
const { promisify } = require('util');

/**
 * CryptoUtils - Utility class for cryptographic operations
 * Provides various helper methods for encryption, decryption, and crypto operations
 */
class CryptoUtils {
    constructor() {
        this.algorithms = {
            AES_256_GCM: 'aes-256-gcm',
            AES_256_CBC: 'aes-256-cbc',
            AES_192_GCM: 'aes-192-gcm',
            RSA_OAEP: 'RSA-OAEP',
            SHA256: 'sha256',
            SHA512: 'sha512',
            SHA384: 'sha384',
            SHA1: 'sha1',
            MD5: 'md5',
            PBKDF2: 'pbkdf2',
            ARGON2: 'argon2id',
            BLAKE2B512: 'blake2b512',
            CHACHA20_POLY1305: 'chacha20-poly1305'
        };

        this.encoding = {
            UTF8: 'utf8',
            BASE64: 'base64',
            BASE64URL: 'base64url',
            HEX: 'hex',
            BINARY: 'binary',
            ASCII: 'ascii',
            LATIN1: 'latin1'
        };

        this.keyLengths = {
            AES_256: 32,
            AES_192: 24,
            AES_128: 16,
            IV_LENGTH: 16,
            SALT_LENGTH: 64,
            TAG_LENGTH: 16,
            NONCE_LENGTH: 24,
            RSA_2048: 2048,
            RSA_4096: 4096,
            ED25519: 256
        };

        this.iterations = {
            PBKDF2_DEFAULT: 100000,
            PBKDF2_HIGH: 200000,
            PBKDF2_ULTRA: 500000,
            SCRYPT_DEFAULT: 16384,
            SCRYPT_HIGH: 32768,
            ARGON2_DEFAULT: 3,
            ARGON2_HIGH: 5
        };

        this.memoryCosts = {
            ARGON2_DEFAULT: 65536,
            ARGON2_HIGH: 131072,
            SCRYPT_DEFAULT: 8,
            SCRYPT_HIGH: 16
        };

        this.parallelism = {
            ARGON2_DEFAULT: 4,
            ARGON2_HIGH: 8,
            SCRYPT_DEFAULT: 1,
            SCRYPT_HIGH: 2
        };

        this.curves = {
            SECP256K1: 'secp256k1',
            SECP384R1: 'secp384r1',
            SECP521R1: 'secp521r1',
            PRIME256V1: 'prime256v1',
            ED25519: 'ed25519',
            ED448: 'ed448',
            X25519: 'x25519',
            X448: 'x448'
        };

        this.cache = new Map();
        this.cacheTimeout = 300000; // 5 minutes
        this.statistics = {
            encryptionOperations: 0,
            decryptionOperations: 0,
            hashingOperations: 0,
            signatureOperations: 0,
            keyGenerationOperations: 0,
            errors: 0
        };
    }

    /**
     * Generate random bytes with entropy validation
     * @param {number} length - Number of bytes to generate
     * @param {boolean} validateEntropy - Whether to validate entropy
     * @returns {Buffer} Random bytes
     */
    generateRandomBytes(length, validateEntropy = false) {
        try {
            const bytes = crypto.randomBytes(length);

            if (validateEntropy) {
                const entropy = this.calculateEntropy(bytes);
                if (entropy < 7.5) {
                    throw new Error('Generated bytes have insufficient entropy');
                }
            }

            return bytes;
        } catch (error) {
            this.statistics.errors++;
            throw new Error(`Failed to generate random bytes: ${error.message}`);
        }
    }

    /**
     * Calculate Shannon entropy of data
     * @param {Buffer} data - Data to analyze
     * @returns {number} Entropy value
     */
    calculateEntropy(data) {
        const frequency = new Map();

        for (const byte of data) {
            frequency.set(byte, (frequency.get(byte) || 0) + 1);
        }

        let entropy = 0;
        const dataLength = data.length;

        for (const count of frequency.values()) {
            const probability = count / dataLength;
            entropy -= probability * Math.log2(probability);
        }

        return entropy;
    }

    /**
     * Generate cryptographically secure random string
     * @param {number} length - Length of string
     * @param {string} charset - Character set to use
     * @returns {string} Random string
     */
    generateRandomString(length, charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789') {
        const bytes = this.generateRandomBytes(length);
        let result = '';

        for (let i = 0; i < length; i++) {
            result += charset[bytes[i] % charset.length];
        }

        return result;
    }

    /**
     * Generate UUID v4 with timestamp
     * @returns {object} UUID and metadata
     */
    generateUUID() {
        const uuid = crypto.randomUUID();
        return {
            uuid,
            timestamp: Date.now(),
            version: 4,
            variant: 'RFC4122'
        };
    }

    /**
     * Generate secure token with metadata
     * @param {number} length - Token length
     * @param {object} options - Token options
     * @returns {object} Token and metadata
     */
    generateSecureToken(length = 32, options = {}) {
        const token = crypto.randomBytes(length).toString(this.encoding.BASE64URL);
        const metadata = {
            token,
            created: new Date().toISOString(),
            expires: options.ttl ? new Date(Date.now() + options.ttl).toISOString() : null,
            purpose: options.purpose || 'general',
            algorithm: 'random',
            length
        };

        if (options.includeChecksum) {
            metadata.checksum = this.createHash(token, this.algorithms.SHA256);
        }

        return metadata;
    }

    /**
     * Create hash with multiple algorithms
     * @param {string|Buffer} data - Data to hash
     * @param {string} algorithm - Hash algorithm
     * @param {object} options - Hash options
     * @returns {object} Hash results
     */
    createHash(data, algorithm = this.algorithms.SHA256, options = {}) {
        try {
            this.statistics.hashingOperations++;

            const hash = crypto.createHash(algorithm);

            if (options.salt) {
                hash.update(options.salt);
            }

            hash.update(data);

            const result = {
                hash: hash.digest(options.encoding || this.encoding.HEX),
                algorithm,
                timestamp: Date.now()
            };

            if (options.includeMultiple) {
                result.alternates = {};
                const algorithms = [this.algorithms.SHA256, this.algorithms.SHA512, this.algorithms.SHA384];

                for (const algo of algorithms) {
                    if (algo !== algorithm) {
                        const altHash = crypto.createHash(algo);
                        if (options.salt) altHash.update(options.salt);
                        altHash.update(data);
                        result.alternates[algo] = altHash.digest(options.encoding || this.encoding.HEX);
                    }
                }
            }

            return result;
        } catch (error) {
            this.statistics.errors++;
            throw new Error(`Hashing failed: ${error.message}`);
        }
    }

    /**
     * Create HMAC with key rotation support
     * @param {string|Buffer} data - Data to HMAC
     * @param {string|Buffer} key - Secret key
     * @param {string} algorithm - Hash algorithm
     * @param {object} options - HMAC options
     * @returns {object} HMAC result
     */
    createHMAC(data, key, algorithm = this.algorithms.SHA256, options = {}) {
        try {
            const hmac = crypto.createHmac(algorithm, key);
            hmac.update(data);

            const result = {
                hmac: hmac.digest(options.encoding || this.encoding.HEX),
                algorithm,
                keyId: options.keyId || null,
                timestamp: Date.now()
            };

            if (options.includeKeyDerivation) {
                const derivedKey = crypto.pbkdf2Sync(key, data, 1000, 32, algorithm);
                result.derivedKeyHmac = crypto.createHmac(algorithm, derivedKey)
                    .update(data)
                    .digest(options.encoding || this.encoding.HEX);
            }

            return result;
        } catch (error) {
            this.statistics.errors++;
            throw new Error(`HMAC creation failed: ${error.message}`);
        }
    }

    /**
     * Derive key using PBKDF2 with options
     * @param {string} password - Password to derive from
     * @param {Buffer} salt - Salt value
     * @param {object} options - Derivation options
     * @returns {Promise<object>} Derived key and metadata
     */
    async deriveKey(password, salt, options = {}) {
        try {
            const iterations = options.iterations || this.iterations.PBKDF2_DEFAULT;
            const keyLength = options.keyLength || this.keyLengths.AES_256;
            const digest = options.digest || this.algorithms.SHA256;

            const pbkdf2 = promisify(crypto.pbkdf2);
            const startTime = Date.now();

            const key = await pbkdf2(password, salt, iterations, keyLength, digest);

            const result = {
                key,
                salt,
                iterations,
                keyLength,
                digest,
                derivationTime: Date.now() - startTime,
                algorithm: 'PBKDF2'
            };

            if (options.deriveMultiple) {
                result.additionalKeys = {};
                const lengths = [16, 24, 32, 48, 64];

                for (const length of lengths) {
                    if (length !== keyLength) {
                        result.additionalKeys[`key${length * 8}`] = await pbkdf2(
                            password, salt, iterations, length, digest
                        );
                    }
                }
            }

            return result;
        } catch (error) {
            this.statistics.errors++;
            throw new Error(`Key derivation failed: ${error.message}`);
        }
    }

    /**
     * Derive key using scrypt with parameters
     * @param {string} password - Password to derive from
     * @param {Buffer} salt - Salt value
     * @param {object} options - Scrypt options
     * @returns {Promise<object>} Derived key and metadata
     */
    async deriveKeyScrypt(password, salt, options = {}) {
        try {
            const keyLength = options.keyLength || this.keyLengths.AES_256;
            const N = options.N || this.iterations.SCRYPT_DEFAULT;
            const r = options.r || this.memoryCosts.SCRYPT_DEFAULT;
            const p = options.p || this.parallelism.SCRYPT_DEFAULT;

            const scrypt = promisify(crypto.scrypt);
            const startTime = Date.now();

            const key = await scrypt(password, salt, keyLength, { N, r, p });

            return {
                key,
                salt,
                keyLength,
                N,
                r,
                p,
                derivationTime: Date.now() - startTime,
                algorithm: 'scrypt',
                memoryUsage: N * r * 128
            };
        } catch (error) {
            this.statistics.errors++;
            throw new Error(`Scrypt key derivation failed: ${error.message}`);
        }
    }

    /**
     * Constant time comparison with length checking
     * @param {Buffer} a - First buffer
     * @param {Buffer} b - Second buffer
     * @returns {boolean} Whether buffers are equal
     */
    constantTimeCompare(a, b) {
        if (a.length !== b.length) {
            // Still perform comparison to maintain constant time
            const dummy = Buffer.alloc(a.length);
            crypto.timingSafeEqual(a, dummy);
            return false;
        }
        return crypto.timingSafeEqual(a, b);
    }

    /**
     * Encrypt data using AES-GCM with AAD
     * @param {string|Buffer} data - Data to encrypt
     * @param {Buffer} key - Encryption key
     * @param {object} options - Encryption options
     * @returns {object} Encrypted data with metadata
     */
    encryptAESGCM(data, key, options = {}) {
        try {
            this.statistics.encryptionOperations++;

            const iv = options.iv || this.generateRandomBytes(this.keyLengths.IV_LENGTH);
            const algorithm = options.algorithm || this.algorithms.AES_256_GCM;
            const cipher = crypto.createCipheriv(algorithm, key, iv);

            if (options.aad) {
                cipher.setAAD(Buffer.from(options.aad));
            }

            const inputEncoding = typeof data === 'string' ? this.encoding.UTF8 : null;
            let encrypted = cipher.update(data, inputEncoding);
            encrypted = Buffer.concat([encrypted, cipher.final()]);

            const authTag = cipher.getAuthTag();

            const result = {
                encrypted: encrypted.toString(this.encoding.BASE64),
                iv: iv.toString(this.encoding.BASE64),
                authTag: authTag.toString(this.encoding.BASE64),
                algorithm,
                timestamp: Date.now()
            };

            if (options.aad) {
                result.aad = Buffer.from(options.aad).toString(this.encoding.BASE64);
            }

            if (options.includeKeyChecksum) {
                result.keyChecksum = this.createHash(key, this.algorithms.SHA256).hash;
            }

            return result;
        } catch (error) {
            this.statistics.errors++;
            throw new Error(`AES-GCM encryption failed: ${error.message}`);
        }
    }

    /**
     * Decrypt data using AES-GCM with validation
     * @param {string} encryptedData - Encrypted data
     * @param {Buffer} key - Decryption key
     * @param {string} iv - Initialization vector
     * @param {string} authTag - Authentication tag
     * @param {object} options - Decryption options
     * @returns {string|Buffer} Decrypted data
     */
    decryptAESGCM(encryptedData, key, iv, authTag, options = {}) {
        try {
            this.statistics.decryptionOperations++;

            const algorithm = options.algorithm || this.algorithms.AES_256_GCM;
            const decipher = crypto.createDecipheriv(
                algorithm,
                key,
                Buffer.from(iv, this.encoding.BASE64)
            );

            decipher.setAuthTag(Buffer.from(authTag, this.encoding.BASE64));

            if (options.aad) {
                decipher.setAAD(Buffer.from(options.aad, this.encoding.BASE64));
            }

            let decrypted = decipher.update(encryptedData, this.encoding.BASE64);
            decrypted = Buffer.concat([decrypted, decipher.final()]);

            if (options.outputEncoding) {
                return decrypted.toString(options.outputEncoding);
            }

            return options.returnBuffer ? decrypted : decrypted.toString(this.encoding.UTF8);
        } catch (error) {
            this.statistics.errors++;
            throw new Error(`AES-GCM decryption failed: ${error.message}`);
        }
    }

    /**
     * Encrypt using ChaCha20-Poly1305
     * @param {string|Buffer} data - Data to encrypt
     * @param {Buffer} key - 32-byte key
     * @param {object} options - Encryption options
     * @returns {object} Encrypted data
     */
    encryptChaCha20(data, key, options = {}) {
        try {
            const nonce = options.nonce || this.generateRandomBytes(12);
            const cipher = crypto.createCipheriv(this.algorithms.CHACHA20_POLY1305, key, nonce);

            if (options.aad) {
                cipher.setAAD(Buffer.from(options.aad));
            }

            let encrypted = cipher.update(data, this.encoding.UTF8);
            encrypted = Buffer.concat([encrypted, cipher.final()]);

            return {
                encrypted: encrypted.toString(this.encoding.BASE64),
                nonce: nonce.toString(this.encoding.BASE64),
                authTag: cipher.getAuthTag().toString(this.encoding.BASE64),
                algorithm: this.algorithms.CHACHA20_POLY1305
            };
        } catch (error) {
            this.statistics.errors++;
            throw new Error(`ChaCha20-Poly1305 encryption failed: ${error.message}`);
        }
    }

    /**
     * Generate RSA key pair with options
     * @param {object} options - Key generation options
     * @returns {Promise<object>} Public and private keys with metadata
     */
    async generateRSAKeyPair(options = {}) {
        try {
            this.statistics.keyGenerationOperations++;

            const modulusLength = options.modulusLength || this.keyLengths.RSA_4096;
            const publicExponent = options.publicExponent || 65537;

            const generateKeyPair = promisify(crypto.generateKeyPair);
            const startTime = Date.now();

            const { publicKey, privateKey } = await generateKeyPair('rsa', {
                modulusLength,
                publicExponent,
                publicKeyEncoding: {
                    type: 'spki',
                    format: 'pem'
                },
                privateKeyEncoding: {
                    type: 'pkcs8',
                    format: 'pem',
                    cipher: options.passphrase ? 'aes-256-cbc' : undefined,
                    passphrase: options.passphrase
                }
            });

            const keyInfo = {
                publicKey,
                privateKey,
                modulusLength,
                publicExponent,
                algorithm: 'RSA',
                generationTime: Date.now() - startTime,
                fingerprint: this.createHash(publicKey, this.algorithms.SHA256).hash,
                created: new Date().toISOString()
            };

            if (options.exportFormats) {
                keyInfo.exports = {
                    publicDER: crypto.createPublicKey(publicKey).export({ type: 'spki', format: 'der' }),
                    privateDER: crypto.createPrivateKey({ key: privateKey, passphrase: options.passphrase })
                        .export({ type: 'pkcs8', format: 'der' })
                };
            }

            return keyInfo;
        } catch (error) {
            this.statistics.errors++;
            throw new Error(`RSA key generation failed: ${error.message}`);
        }
    }

    /**
     * Generate elliptic curve key pair
     * @param {object} options - Key generation options
     * @returns {Promise<object>} EC key pair with metadata
     */
    async generateECKeyPair(options = {}) {
        try {
            this.statistics.keyGenerationOperations++;

            const namedCurve = options.namedCurve || this.curves.SECP256K1;
            const generateKeyPair = promisify(crypto.generateKeyPair);
            const startTime = Date.now();

            const { publicKey, privateKey } = await generateKeyPair('ec', {
                namedCurve,
                publicKeyEncoding: {
                    type: 'spki',
                    format: 'pem'
                },
                privateKeyEncoding: {
                    type: 'pkcs8',
                    format: 'pem',
                    cipher: options.passphrase ? 'aes-256-cbc' : undefined,
                    passphrase: options.passphrase
                }
            });

            return {
                publicKey,
                privateKey,
                namedCurve,
                algorithm: 'EC',
                generationTime: Date.now() - startTime,
                fingerprint: this.createHash(publicKey, this.algorithms.SHA256).hash,
                created: new Date().toISOString()
            };
        } catch (error) {
            this.statistics.errors++;
            throw new Error(`EC key generation failed: ${error.message}`);
        }
    }

    /**
     * Generate Ed25519 key pair
     * @param {object} options - Key generation options
     * @returns {Promise<object>} Ed25519 key pair
     */
    async generateEd25519KeyPair(options = {}) {
        try {
            this.statistics.keyGenerationOperations++;

            const generateKeyPair = promisify(crypto.generateKeyPair);
            const { publicKey, privateKey } = await generateKeyPair('ed25519', {
                publicKeyEncoding: {
                    type: 'spki',
                    format: 'pem'
                },
                privateKeyEncoding: {
                    type: 'pkcs8',
                    format: 'pem',
                    cipher: options.passphrase ? 'aes-256-cbc' : undefined,
                    passphrase: options.passphrase
                }
            });

            return {
                publicKey,
                privateKey,
                algorithm: 'Ed25519',
                curve: 'ed25519',
                fingerprint: this.createHash(publicKey, this.algorithms.SHA256).hash
            };
        } catch (error) {
            this.statistics.errors++;
            throw new Error(`Ed25519 key generation failed: ${error.message}`);
        }
    }

    /**
     * Sign data with private key and options
     * @param {string|Buffer} data - Data to sign
     * @param {string} privateKey - Private key
     * @param {object} options - Signing options
     * @returns {object} Signature and metadata
     */
    signData(data, privateKey, options = {}) {
        try {
            this.statistics.signatureOperations++;

            const algorithm = options.algorithm || 'RSA-SHA256';
            const sign = crypto.createSign(algorithm);

            sign.update(data);
            sign.end();

            const signature = sign.sign({
                key: privateKey,
                passphrase: options.passphrase
            }, this.encoding.BASE64);

            return {
                signature,
                algorithm,
                timestamp: Date.now(),
                dataHash: this.createHash(data, this.algorithms.SHA256).hash
            };
        } catch (error) {
            this.statistics.errors++;
            throw new Error(`Data signing failed: ${error.message}`);
        }
    }

    /**
     * Verify signature with public key
     * @param {string|Buffer} data - Original data
     * @param {string} signature - Signature to verify
     * @param {string} publicKey - Public key
     * @param {object} options - Verification options
     * @returns {object} Verification result
     */
    verifySignature(data, signature, publicKey, options = {}) {
        try {
            this.statistics.signatureOperations++;

            const algorithm = options.algorithm || 'RSA-SHA256';
            const verify = crypto.createVerify(algorithm);

            verify.update(data);
            verify.end();

            const isValid = verify.verify(publicKey, signature, this.encoding.BASE64);

            return {
                isValid,
                algorithm,
                timestamp: Date.now(),
                dataHash: this.createHash(data, this.algorithms.SHA256).hash
            };
        } catch (error) {
            this.statistics.errors++;
            return {
                isValid: false,
                error: error.message,
                timestamp: Date.now()
            };
        }
    }

    /**
     * Create secure password hash with Argon2
     * @param {string} password - Password to hash
     * @param {object} options - Hashing options
     * @returns {Promise<object>} Hash and metadata
     */
    async createPasswordHash(password, options = {}) {
        try {
            const salt = options.salt || this.generateRandomBytes(this.keyLengths.SALT_LENGTH);
            const iterations = options.iterations || this.iterations.PBKDF2_HIGH;
            const keyLength = options.keyLength || 32;

            const hash = await this.deriveKey(password, salt, {
                iterations,
                keyLength,
                digest: this.algorithms.SHA512
            });

            const result = {
                hash: hash.key.toString(this.encoding.BASE64),
                salt: salt.toString(this.encoding.BASE64),
                iterations,
                keyLength,
                algorithm: 'PBKDF2-SHA512',
                created: new Date().toISOString()
            };

            if (options.includeScrypt) {
                const scryptResult = await this.deriveKeyScrypt(password, salt, { keyLength });
                result.scryptHash = scryptResult.key.toString(this.encoding.BASE64);
                result.scryptParams = {
                    N: scryptResult.N,
                    r: scryptResult.r,
                    p: scryptResult.p
                };
            }

            return result;
        } catch (error) {
            this.statistics.errors++;
            throw new Error(`Password hashing failed: ${error.message}`);
        }
    }

    /**
     * Verify password against hash with timing safety
     * @param {string} password - Password to verify
     * @param {string} hash - Stored hash
     * @param {string} salt - Stored salt
     * @param {object} options - Verification options
     * @returns {Promise<object>} Verification result
     */
    async verifyPassword(password, hash, salt, options = {}) {
        try {
            const iterations = options.iterations || this.iterations.PBKDF2_HIGH;
            const keyLength = options.keyLength || 32;

            const saltBuffer = Buffer.from(salt, this.encoding.BASE64);
            const hashBuffer = Buffer.from(hash, this.encoding.BASE64);

            const derivedKey = await this.deriveKey(password, saltBuffer, {
                iterations,
                keyLength,
                digest: options.digest || this.algorithms.SHA512
            });

            const isValid = this.constantTimeCompare(derivedKey.key, hashBuffer);

            return {
                isValid,
                timestamp: Date.now(),
                iterations,
                algorithm: options.algorithm || 'PBKDF2-SHA512'
            };
        } catch (error) {
            this.statistics.errors++;
            return {
                isValid: false,
                error: error.message,
                timestamp: Date.now()
            };
        }
    }

    /**
     * Encrypt file using streams
     * @param {string} inputPath - Input file path
     * @param {string} outputPath - Output file path
     * @param {Buffer} key - Encryption key
     * @param {object} options - Encryption options
     * @returns {Promise<object>} Encryption metadata
     */
    async encryptFile(inputPath, outputPath, key, options = {}) {
        const fs = require('fs');
        const stream = require('stream');
        const pipeline = promisify(stream.pipeline);

        try {
            const iv = this.generateRandomBytes(this.keyLengths.IV_LENGTH);
            const algorithm = options.algorithm || this.algorithms.AES_256_GCM;
            const cipher = crypto.createCipheriv(algorithm, key, iv);

            const input = fs.createReadStream(inputPath);
            const output = fs.createWriteStream(outputPath);

            await pipeline(input, cipher, output);

            const stats = fs.statSync(outputPath);

            return {
                iv: iv.toString(this.encoding.BASE64),
                authTag: cipher.getAuthTag().toString(this.encoding.BASE64),
                algorithm,
                originalSize: fs.statSync(inputPath).size,
                encryptedSize: stats.size,
                timestamp: Date.now()
            };
        } catch (error) {
            this.statistics.errors++;
            throw new Error(`File encryption failed: ${error.message}`);
        }
    }

    /**
     * Decrypt file using streams
     * @param {string} inputPath - Input file path
     * @param {string} outputPath - Output file path
     * @param {Buffer} key - Decryption key
     * @param {string} iv - Initialization vector
     * @param {string} authTag - Authentication tag
     * @param {object} options - Decryption options
     * @returns {Promise<object>} Decryption metadata
     */
    async decryptFile(inputPath, outputPath, key, iv, authTag, options = {}) {
        const fs = require('fs');
        const stream = require('stream');
        const pipeline = promisify(stream.pipeline);

        try {
            const algorithm = options.algorithm || this.algorithms.AES_256_GCM;
            const decipher = crypto.createDecipheriv(
                algorithm,
                key,
                Buffer.from(iv, this.encoding.BASE64)
            );

            decipher.setAuthTag(Buffer.from(authTag, this.encoding.BASE64));

            const input = fs.createReadStream(inputPath);
            const output = fs.createWriteStream(outputPath);

            await pipeline(input, decipher, output);

            return {
                success: true,
                algorithm,
                decryptedSize: fs.statSync(outputPath).size,
                timestamp: Date.now()
            };
        } catch (error) {
            this.statistics.errors++;
            throw new Error(`File decryption failed: ${error.message}`);
        }
    }

    /**
     * Calculate file checksum with progress
     * @param {string} filePath - File path
     * @param {string} algorithm - Hash algorithm
     * @param {function} progressCallback - Progress callback
     * @returns {Promise<object>} Checksum and metadata
     */
    async calculateFileChecksum(filePath, algorithm = this.algorithms.SHA256, progressCallback = null) {
        const fs = require('fs');

        return new Promise((resolve, reject) => {
            try {
                const hash = crypto.createHash(algorithm);
                const stream = fs.createReadStream(filePath);
                const stats = fs.statSync(filePath);
                let processed = 0;

                stream.on('data', (data) => {
                    hash.update(data);
                    processed += data.length;

                    if (progressCallback) {
                        progressCallback({
                            processed,
                            total: stats.size,
                            percentage: (processed / stats.size) * 100
                        });
                    }
                });

                stream.on('end', () => {
                    resolve({
                        checksum: hash.digest(this.encoding.HEX),
                        algorithm,
                        fileSize: stats.size,
                        timestamp: Date.now()
                    });
                });

                stream.on('error', (error) => {
                    this.statistics.errors++;
                    reject(error);
                });
            } catch (error) {
                this.statistics.errors++;
                reject(error);
            }
        });
    }

    /**
     * Generate TOTP secret and QR code data
     * @param {object} options - TOTP options
     * @returns {object} TOTP secret and metadata
     */
    generateTOTPSecret(options = {}) {
        const secret = this.generateRandomBytes(options.length || 32);
        const base32Secret = this.base32Encode(secret);

        const otpauth = `otpauth://totp/${options.label || 'App'}?secret=${base32Secret}&issuer=${options.issuer || 'Company'}`;

        return {
            secret: base32Secret,
            qrCode: otpauth,
            algorithm: options.algorithm || 'SHA1',
            digits: options.digits || 6,
            period: options.period || 30
        };
    }

    /**
     * Base32 encoding for TOTP
     * @param {Buffer} buffer - Buffer to encode
     * @returns {string} Base32 encoded string
     */
    base32Encode(buffer) {
        const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
        let result = '';
        let bits = 0;
        let value = 0;

        for (let i = 0; i < buffer.length; i++) {
            value = (value << 8) | buffer[i];
            bits += 8;

            while (bits >= 5) {
                result += alphabet[(value >>> (bits - 5)) & 31];
                bits -= 5;
            }
        }

        if (bits > 0) {
            result += alphabet[(value << (5 - bits)) & 31];
        }

        return result;
    }

    /**
     * Get cryptography statistics
     * @returns {object} Statistics object
     */
    getStatistics() {
        return {
            ...this.statistics,
            cacheSize: this.cache.size,
            uptime: process.uptime(),
            memoryUsage: process.memoryUsage()
        };
    }

    /**
     * Clear cache and reset statistics
     */
    clearCache() {
        this.cache.clear();
        this.statistics = {
            encryptionOperations: 0,
            decryptionOperations: 0,
            hashingOperations: 0,
            signatureOperations: 0,
            keyGenerationOperations: 0,
            errors: 0
        };
    }
}

module.exports = CryptoUtils;
